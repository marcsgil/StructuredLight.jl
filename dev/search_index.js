var documenterSearchIndex = {"docs":
[{"location":"holograms/#Holograms","page":"Holograms","title":"Holograms","text":"","category":"section"},{"location":"holograms/","page":"Holograms","title":"Holograms","text":"This section covers the generation of computer-generated holograms (CGHs) for spatial light modulators (SLMs). The StructuredLight.jl package provides algorithms to convert complex beam profiles into phase patterns that can be displayed on phase-only SLMs. In order to display the holograms in the SLM, we suggest the package SpatialLightModulator.jl","category":"page"},{"location":"holograms/#Overview","page":"Holograms","title":"Overview","text":"","category":"section"},{"location":"holograms/","page":"Holograms","title":"Holograms","text":"Computer-generated holograms encode both amplitude and phase information of a desired optical field into a phase-only pattern. This is essential for spatial light modulators that can only modulate the phase of light.","category":"page"},{"location":"holograms/","page":"Holograms","title":"Holograms","text":"The basic idea is to take a complex field (which can be a superposition of different modes) and convert it into a phase pattern that can be displayed on an SLM. The hologram generation process involves calculating the phase shift required for each pixel to reconstruct the desired field at a specific distance.","category":"page"},{"location":"holograms/#Theoretical-Background","page":"Holograms","title":"Theoretical Background","text":"","category":"section"},{"location":"holograms/#Computer-Generated-Holograms-(CGHs)","page":"Holograms","title":"Computer-Generated Holograms (CGHs)","text":"","category":"section"},{"location":"holograms/","page":"Holograms","title":"Holograms","text":"Computer-generated holograms solve a fundamental challenge in optics: how to display complex-valued optical fields (with both amplitude and phase information) on devices that can only modulate one parameter. Most spatial light modulators (SLMs) can only control phase, not amplitude.","category":"page"},{"location":"holograms/#The-Phase-Only-Constraint","page":"Holograms","title":"The Phase-Only Constraint","text":"","category":"section"},{"location":"holograms/","page":"Holograms","title":"Holograms","text":"When we want to create a desired optical field ψtarget(x,y) = |ψtarget| exp(iφtarget), but our SLM can only apply phase modulation exp(iφSLM), we need to encode both amplitude and phase information into the phase pattern φ_SLM.","category":"page"},{"location":"holograms/#Holographic-Encoding-Methods","page":"Holograms","title":"Holographic Encoding Methods","text":"","category":"section"},{"location":"holograms/","page":"Holograms","title":"Holograms","text":"CGHs work by adding a reference wave (carrier frequency) to the desired field. The interference between target and reference creates an intensity pattern that, when converted to phase, reconstructs the original field in specific diffraction orders:","category":"page"},{"location":"holograms/","page":"Holograms","title":"Holograms","text":"Zero order: Unmodulated reference beam\nFirst order: Desired reconstructed field  \nHigher orders: Unwanted copies","category":"page"},{"location":"holograms/","page":"Holograms","title":"Holograms","text":"The period parameters xperiod and yperiod control the carrier frequency, determining the spatial separation between diffraction orders. Proper choice of these parameters ensures the desired field is spatially separated from unwanted diffraction orders.","category":"page"},{"location":"holograms/#Amplitude-Encoding-Strategies","page":"Holograms","title":"Amplitude Encoding Strategies","text":"","category":"section"},{"location":"holograms/","page":"Holograms","title":"Holograms","text":"The package implements two main approaches for encoding amplitude information:","category":"page"},{"location":"holograms/","page":"Holograms","title":"Holograms","text":"BesselJ1 Method: Uses the inverse Bessel function relationship between phase modulation depth and first-order diffraction efficiency\nSimple Method: Direct amplitude-to-phase mapping with blazed grating, simpler but less efficient","category":"page"},{"location":"holograms/","page":"Holograms","title":"Holograms","text":"Here's a simple example of how to generate a hologram for a Laguerre-Gaussian beam:","category":"page"},{"location":"holograms/","page":"Holograms","title":"Holograms","text":"using StructuredLight, CairoMakie\n\n# Create coordinate arrays\n# Should have the resolution of the SLM\nx = LinRange(-5, 5, 512)\ny = LinRange(-5, 5, 512)\n\n# Generate a Laguerre-Gaussian beam with topological charge l=2\nbeam = lg(x, y, l=2)\n\n# Create hologram with the default method (BesselJ1)\n# We specify the two_pi_modulation, x_period, and y_period\nhologram = generate_hologram(beam, 255, 20, 20)\n\n# Visualize the hologram\n# For displaying in the SLM, you would typically use a package like SpatialLightModulator.jl\nvisualize(hologram, colormap = :grays)","category":"page"},{"location":"holograms/","page":"Holograms","title":"Holograms","text":"One can see the distinct fork structure of the vortex beam in the hologram.","category":"page"},{"location":"holograms/#Description","page":"Holograms","title":"Description","text":"","category":"section"},{"location":"holograms/","page":"Holograms","title":"Holograms","text":"The main functions for hologram generation are:","category":"page"},{"location":"holograms/","page":"Holograms","title":"Holograms","text":"generate_hologram\ngenerate_hologram!","category":"page"},{"location":"holograms/#StructuredLight.generate_hologram","page":"Holograms","title":"StructuredLight.generate_hologram","text":"generate_hologram(relative, two_pi_modulation, x_period, y_period, method::T=BesselJ1()) where {T<:HologramMethod}\n\nReturns a hologram built from the relative field, using the specified method.\n\nArguments\n\nrelative: a matrix of complex numbers representing the relative field. This is the field one wishes to produce divided by the field that arrives at the hologram plane.\ntwo_pi_modulation: an integer between 0 and 255 the representing modulation level that produces a phase shift of 2π. Check your SLM specifications to see what this value should be.\nx_period and y_period are the periods, in units of pixels, of the diffraction grating in the x and y directions. This is used to spatially separate the modulated beam (first order diffraction) from the unmodulated beam (zero order diffraction).\n\nThe avaliable methods are BesselJ1 and Simple.\n\nSe also generate_hologram!.\n\nExamples\n\nx = -5:5\ny = -5:5\nrelative = lg(x, y, l=1)\nholo = generate_hologram(relative, 255, 2, 2)\n\n# output\n\n11×11 Matrix{UInt8}:\n 0x4b  0x4b  0x4b  0x4b  0x4b  0x4b  0x4b  0x4b  0x4b  0x4b  0x4b\n 0x4b  0x4b  0x4b  0x4b  0x4b  0x4b  0x4b  0x4b  0x4b  0x4b  0x4b\n 0x4b  0x4b  0x4b  0x4b  0x4b  0x4b  0x4b  0x4b  0x4b  0x4b  0x4b\n 0x4b  0x4b  0x4b  0x4b  0x4c  0x4b  0x4a  0x4b  0x4b  0x4b  0x4b\n 0x4b  0x4b  0x4b  0x4c  0x38  0x4b  0x5d  0x49  0x4b  0x4b  0x4b\n 0x4b  0x4b  0x4b  0x46  0x95  0x4b  0x00  0x4f  0x4b  0x4b  0x4b\n 0x4b  0x4b  0x4b  0x4c  0x38  0x4b  0x5d  0x49  0x4b  0x4b  0x4b\n 0x4b  0x4b  0x4b  0x4b  0x4c  0x4b  0x4a  0x4b  0x4b  0x4b  0x4b\n 0x4b  0x4b  0x4b  0x4b  0x4b  0x4b  0x4b  0x4b  0x4b  0x4b  0x4b\n 0x4b  0x4b  0x4b  0x4b  0x4b  0x4b  0x4b  0x4b  0x4b  0x4b  0x4b\n 0x4b  0x4b  0x4b  0x4b  0x4b  0x4b  0x4b  0x4b  0x4b  0x4b  0x4b\n\nx = -5:5\ny = -5:5\nrelative = lg(x, y, l=1)\nholo = generate_hologram(relative, 255, 2, 2, Simple())\n\n# output\n\n11×11 Matrix{UInt8}:\n 0x80  0x80  0x7f  0x80  0x7f  0x80  0x80  0x7f  0x80  0x80  0x80\n 0x80  0x7f  0x80  0x7f  0x80  0x80  0x7f  0x80  0x7f  0x80  0x80\n 0x7f  0x80  0x7f  0x80  0x7f  0x80  0x80  0x7f  0x80  0x7f  0x80\n 0x80  0x7f  0x80  0x7f  0x80  0x8c  0x7f  0x80  0x7f  0x80  0x7f\n 0x7f  0x80  0x7f  0x81  0x4e  0x80  0xb1  0x7e  0x80  0x7f  0x80\n 0x80  0x7f  0x80  0x79  0xbf  0x80  0x40  0x86  0x7f  0x80  0x7f\n 0x7f  0x80  0x7f  0x83  0x6f  0x00  0x90  0x7c  0x80  0x7f  0x80\n 0x80  0x7f  0x80  0x7f  0x84  0x7f  0x7b  0x80  0x7f  0x80  0x7f\n 0x7f  0x80  0x7f  0x80  0x7f  0x80  0x80  0x7f  0x80  0x7f  0x80\n 0x80  0x7f  0x80  0x7f  0x80  0x80  0x7f  0x80  0x7f  0x80  0x80\n 0x80  0x80  0x7f  0x80  0x7f  0x7f  0x80  0x7f  0x80  0x80  0x80\n\nReferences\n\n[1] Victor Arrizón, Ulises Ruiz, Rosibel Carrada, and Luis A. González, \"Pixelated phase computer holograms for the accurate encoding of scalar complex fields,\" J. Opt. Soc. Am. A 24, 3500-3507 (2007)\n\n[2] Thomas W. Clark, Rachel F. Offer, Sonja Franke-Arnold, Aidan S. Arnold, and Neal Radwell,  \"Comparison of beam generation techniques using a phase only spatial light modulator,\"  Opt. Express 24, 6249-6264 (2016)\n\n\n\n\n\n","category":"function"},{"location":"holograms/#StructuredLight.generate_hologram!","page":"Holograms","title":"StructuredLight.generate_hologram!","text":"generate_hologram!(dest, relative, two_pi_modulation, x_period, y_period, method::T=BesselJ1()) where {T<:HologramMethod}\n\nSame as generate_hologram, but writes the result to dest.\n\n\n\n\n\n","category":"function"},{"location":"holograms/","page":"Holograms","title":"Holograms","text":"These functions take a relative field, as well as extra parameters and output phase pattern suitable for SLMs. The relative field is the desired field divided by the input field at the hologram plane. When the input field is a large Gaussian beam, we can approximate it as a plane wave, and the relative field becomes simply the desired field.","category":"page"},{"location":"holograms/","page":"Holograms","title":"Holograms","text":"The other parameters are:","category":"page"},{"location":"holograms/","page":"Holograms","title":"Holograms","text":"two_pi_modulation: Integer value between 0 and 255 that produces 2π phase modulation (check your SLM specifications)\nx_period, y_period: Period, in pixels, of the diffraction grating for the x and y directions","category":"page"},{"location":"holograms/","page":"Holograms","title":"Holograms","text":"The package implements two well-established hologram generation methods:","category":"page"},{"location":"holograms/","page":"Holograms","title":"Holograms","text":"BesselJ1 Method: Based on the inverse of the Bessel J₁ function, providing high-quality amplitude encoding","category":"page"},{"location":"holograms/","page":"Holograms","title":"Holograms","text":"BesselJ1","category":"page"},{"location":"holograms/#StructuredLight.BesselJ1","page":"Holograms","title":"StructuredLight.BesselJ1","text":"BesselJ1 <: HologramMethod\n\nA hologram generation method based on the inverse of the BesselJ1 function.  Corresponds to method of 3 of [1] and F of [2]. Better quality than Simple for most cases, but less efficient in terms of output power.\n\nSee also Simple.\n\nReferences\n\n[1] Victor Arrizón, Ulises Ruiz, Rosibel Carrada, and Luis A. González, \"Pixelated phase computer holograms for the accurate encoding of scalar complex fields,\" J. Opt. Soc. Am. A 24, 3500-3507 (2007)\n\n[2] Thomas W. Clark, Rachel F. Offer, Sonja Franke-Arnold, Aidan S. Arnold, and Neal Radwell,  \"Comparison of beam generation techniques using a phase only spatial light modulator,\"  Opt. Express 24, 6249-6264 (2016)\n\n\n\n\n\n","category":"type"},{"location":"holograms/","page":"Holograms","title":"Holograms","text":"Simple Method: A straightforward amplitude modulation approach with direct phase encoding","category":"page"},{"location":"holograms/","page":"Holograms","title":"Holograms","text":"Simple","category":"page"},{"location":"holograms/#StructuredLight.Simple","page":"Holograms","title":"StructuredLight.Simple","text":"Simple <: HologramMethod\n\nA hologram generation with a naive amplitude modulation. Method of 3 of [1] and F of [2]. Better efficiency in terms of output power than BesselJ1, but lower quality.\n\nSee also BesselJ1.\n\nReferences\n\n[1] Victor Arrizón, Ulises Ruiz, Rosibel Carrada, and Luis A. González, \"Pixelated phase computer holograms for the accurate encoding of scalar complex fields,\" J. Opt. Soc. Am. A 24, 3500-3507 (2007)\n\n[2] Thomas W. Clark, Rachel F. Offer, Sonja Franke-Arnold, Aidan S. Arnold, and Neal Radwell,  \"Comparison of beam generation techniques using a phase only spatial light modulator,\"  Opt. Express 24, 6249-6264 (2016)\n\n\n\n\n\n","category":"type"},{"location":"holograms/#Example:-Hermite-Gaussian-Mode-Hologram","page":"Holograms","title":"Example: Hermite-Gaussian Mode Hologram","text":"","category":"section"},{"location":"holograms/","page":"Holograms","title":"Holograms","text":"using StructuredLight, CairoMakie\n\n# Create coordinate arrays\n# Should have the resolution of the SLM\nx = LinRange(-5, 5, 512)\ny = LinRange(-5, 5, 512)\n\n# Generate a Hermite-Gaussian beam with m=2, n=2\nbeam = hg(x, y, m=2, n=2)\n\n# Create hologram with the Simple() method\n# We specify the two_pi_modulation, x_period, and y_period\nhologram = generate_hologram(beam, 255, 20, 20, Simple())\n\n# Visualize the hologram\nvisualize(hologram, colormap = :grays)","category":"page"},{"location":"holograms/#Creating-Superposition-States","page":"Holograms","title":"Creating Superposition States","text":"","category":"section"},{"location":"holograms/","page":"Holograms","title":"Holograms","text":"using StructuredLight, CairoMakie\n\n# Create superposition of LG modes\nx = LinRange(-8, 8, 512)\ny = LinRange(-8, 8, 512)\n\n# Individual modes\nlg_0_1 = lg(x, y, p=0, l=1, w=3.0)\nlg_0_minus1 = lg(x, y, p=0, l=-1, w=3.0)\n\n# Superposition (equal weights)\nsuperposition = lg_0_1 + 0.5 * lg_0_minus1\n\n# Generate hologram\nsuper_hologram = generate_hologram(superposition, 255, 30, 30)\nvisualize(super_hologram, colormap=:grays)","category":"page"},{"location":"holograms/#Gaussian-input","page":"Holograms","title":"Gaussian input","text":"","category":"section"},{"location":"holograms/","page":"Holograms","title":"Holograms","text":"using StructuredLight, CairoMakie\n\n# Create coordinate arrays\nx = LinRange(-5, 5, 512)\ny = LinRange(-5, 5, 512)\n\n# We wish to produce a Laguerre-Gaussian beam with l=3 \ndesired = lg(x, y, l = 3)\n\n# But the input is a gaussian beam\ninput = lg(x, y, w=2)\n\n# Define the relative field\nrelative_field = desired ./ input\n\n# Generate hologram for the relative field\nhologram_relative = generate_hologram(relative_field, 255, 20, 20)\n\nvisualize(hologram_relative, colormap = :grays)","category":"page"},{"location":"holograms/#GPU-Accelerated-Hologram-Generation","page":"Holograms","title":"GPU-Accelerated Hologram Generation","text":"","category":"section"},{"location":"holograms/","page":"Holograms","title":"Holograms","text":"using StructuredLight, CUDA\n\n# Create beam on GPU\n# We use Float32 for better performance on GPU\nx = LinRange(-5f0, 5f0, 1024)\ny = LinRange(-5f0, 5f0, 1024)\nbeam_gpu = lg(x, y, p=0, l=3, w=2.5, backend=CUDABackend())\n\n# Generate hologram on GPU\nhologram_gpu = generate_hologram(beam_gpu, 255, 20, 20)\n\n# Transfer back to CPU if needed\nhologram_cpu = Array(hologram_gpu)","category":"page"},{"location":"phase_modulation/#Phase-Modulation","page":"Phase Modulation","title":"Phase Modulation","text":"","category":"section"},{"location":"phase_modulation/","page":"Phase Modulation","title":"Phase Modulation","text":"The phase modulation tools in StructuredLight.jl provide a flexible framework for simulating optical elements, correcting aberrations, and implementing custom phase patterns commonly used in adaptive optics, spatial light modulator applications, and structured light generation. This includes simulating optical elements like lenses, correcting aberrations, and applying custom phase masks. The phase modulation framework is general-purpose and can be used for any application requiring spatially-varying phase modifications.","category":"page"},{"location":"phase_modulation/#Physical-Background","page":"Phase Modulation","title":"Physical Background","text":"","category":"section"},{"location":"phase_modulation/#What-is-Phase-Modulation?","page":"Phase Modulation","title":"What is Phase Modulation?","text":"","category":"section"},{"location":"phase_modulation/","page":"Phase Modulation","title":"Phase Modulation","text":"Phase modulation involves spatially varying the phase of an optical field while preserving its amplitude. When light with complex amplitude ψ(x,y) encounters a phase modulating element, the transmitted field becomes:","category":"page"},{"location":"phase_modulation/","page":"Phase Modulation","title":"Phase Modulation","text":"ψout(x,y) = ψin(x,y) × exp(iφ(x,y))","category":"page"},{"location":"phase_modulation/","page":"Phase Modulation","title":"Phase Modulation","text":"where φ(x,y) is the spatially-varying phase function introduced by the optical element.","category":"page"},{"location":"phase_modulation/#Applications-and-Physical-Significance","page":"Phase Modulation","title":"Applications and Physical Significance","text":"","category":"section"},{"location":"phase_modulation/","page":"Phase Modulation","title":"Phase Modulation","text":"Focusing and defocusing: Lenses introduce quadratic phase profiles that focus or diverge light\nAberration correction: Zernike polynomials represent common optical aberrations in adaptive optics systems\nBeam steering: Linear phase gradients deflect beams to different angles\nWavefront shaping: Custom phase patterns can create complex intensity distributions\nAdaptive optics: Real-time phase correction compensates for atmospheric turbulence","category":"page"},{"location":"phase_modulation/#Mathematical-Framework","page":"Phase Modulation","title":"Mathematical Framework","text":"","category":"section"},{"location":"phase_modulation/","page":"Phase Modulation","title":"Phase Modulation","text":"The phase modulation functions in this package implement standard optical transformations:","category":"page"},{"location":"phase_modulation/","page":"Phase Modulation","title":"Phase Modulation","text":"Thin lens: φ(x,y) = -k(x²/2fx + y²/2fy) where fx, fy are focal lengths\nZernike aberrations: φ(x,y) = Σ aᵢ Zᵢ(ρ,θ) for aberration coefficients aᵢ\nCustom patterns: Linear combinations of basis functions for complex wavefront control","category":"page"},{"location":"phase_modulation/#Optical-Elements","page":"Phase Modulation","title":"Optical Elements","text":"","category":"section"},{"location":"phase_modulation/#Lenses","page":"Phase Modulation","title":"Lenses","text":"","category":"section"},{"location":"phase_modulation/","page":"Phase Modulation","title":"Phase Modulation","text":"The package provides functions to simulate the phase modulation introduced by lenses:","category":"page"},{"location":"phase_modulation/","page":"Phase Modulation","title":"Phase Modulation","text":"lens\nlens!\ntilted_lens\ntilted_lens!","category":"page"},{"location":"phase_modulation/#StructuredLight.lens","page":"Phase Modulation","title":"StructuredLight.lens","text":"lens(x, y, fx, fy; k=1, backend=CPU())\n\nOutput an array containing the phase shift introduced by a lens of focal lengths fx and fy:\n\nexpleft-i k left( fracx^22 f_x + fracy^22 f_y right)right\n\nThe calculation is done over a grid defined by x and y.\n\nk is the incident wavenumber.\n\nTo apply the lens at a beam ψ₀, just calculate ψ = ψ₀ .* lens(x,y,fx,fy;k=k)\n\n\n\n\n\n","category":"function"},{"location":"phase_modulation/#StructuredLight.lens!","page":"Phase Modulation","title":"StructuredLight.lens!","text":"lens!(dest, x, y, fx, fy; k=1)\n\nSame as lens, but writes the result to dest.\n\n\n\n\n\n","category":"function"},{"location":"phase_modulation/#StructuredLight.tilted_lens","page":"Phase Modulation","title":"StructuredLight.tilted_lens","text":"tilted_lens(x,y,f,ϕ;k=1)\n\nOutput an array containing the phase shift introduced by a spherical lens of focal length f tilted by an angle ϕ.\n\nThis is a special case of the lens function, where the focal lengths are adjusted based on the tilt angle: f_x = sec(ϕ) * f and f_y = cos(ϕ) * f.\n\nThe calculation is done over a grid defined by x and y.\n\nk is the incident wavenumber.\n\nTo apply the lens at a beam ψ₀, just calculate ψ = ψ₀ .* tilted_lens(x,y,f,ϕ;k=k)\n\n\n\n\n\n","category":"function"},{"location":"phase_modulation/#StructuredLight.tilted_lens!","page":"Phase Modulation","title":"StructuredLight.tilted_lens!","text":"tilted_lens!(dest, x, y, f, ϕ; k=1)\n\nSame as tilted_lens, but writes the result to dest.\n\n\n\n\n\n","category":"function"},{"location":"phase_modulation/#Basic-Lens-Example","page":"Phase Modulation","title":"Basic Lens Example","text":"","category":"section"},{"location":"phase_modulation/","page":"Phase Modulation","title":"Phase Modulation","text":"using StructuredLight, CairoMakie\n\n# Create coordinate grids\nx = LinRange(-4, 4, 512)\ny = LinRange(-4, 4, 512)\nz = LinRange(0, 0.5, 128)\n\n# Generate a Hermite-Gaussian beam\nψ₀ = hg(x, y, m=1, n=1)\n\n# Apply a lens with focal length f=10\nf = 0.5\nlens_phase = lens(x, y, f, f)\n\n# The beam is focused after propagation through the lens\nψ_focused = free_propagation(ψ₀ .* lens_phase, x, y, z)\n\nsave_animation(abs2.(ψ_focused), \"focused_beam.mp4\")\nreturn nothing # hide","category":"page"},{"location":"phase_modulation/","page":"Phase Modulation","title":"Phase Modulation","text":"(Image: )","category":"page"},{"location":"phase_modulation/#Astigmatic-Lens-Example","page":"Phase Modulation","title":"Astigmatic Lens Example","text":"","category":"section"},{"location":"phase_modulation/","page":"Phase Modulation","title":"Phase Modulation","text":"For creating astigmatic focusing with different focal lengths in x and y:","category":"page"},{"location":"phase_modulation/","page":"Phase Modulation","title":"Phase Modulation","text":"using StructuredLight # hide\nx = LinRange(-4, 4, 256) # hide\ny = LinRange(-4, 4, 256) # hide\nψ₀ = hg(x, y, m=1, n=1) # hide\nk = 1.0 # hide\n\n# Different focal lengths in x and y directions\nfx, fy = 8.0, 12.0\nastigmatic_lens = lens(x, y, fx, fy; k=k)\nψ_astigmatic = ψ₀ .* astigmatic_lens\n\nnothing # hide","category":"page"},{"location":"phase_modulation/#Tilted-Lens-Example","page":"Phase Modulation","title":"Tilted Lens Example","text":"","category":"section"},{"location":"phase_modulation/","page":"Phase Modulation","title":"Phase Modulation","text":"For simulating a tilted spherical lens:","category":"page"},{"location":"phase_modulation/","page":"Phase Modulation","title":"Phase Modulation","text":"using StructuredLight # hide\nx = LinRange(-4, 4, 256) # hide\ny = LinRange(-4, 4, 256) # hide\nψ₀ = hg(x, y, m=1, n=1) # hide\nk = 1.0 # hide\n\n# Lens tilted by 15 degrees\nf = 10.0\nϕ = π/12  # 15 degrees in radians\ntilted_lens_phase = tilted_lens(x, y, f, ϕ; k=k)\nψ_tilted = ψ₀ .* tilted_lens_phase\n\nnothing # hide","category":"page"},{"location":"phase_modulation/#Zernike-Polynomials","page":"Phase Modulation","title":"Zernike Polynomials","text":"","category":"section"},{"location":"phase_modulation/","page":"Phase Modulation","title":"Phase Modulation","text":"Zernike polynomials are the standard basis for describing optical aberrations. They form a complete orthogonal set over the unit circle.","category":"page"},{"location":"phase_modulation/","page":"Phase Modulation","title":"Phase Modulation","text":"zernike_polynomial\nzernike_polynomial!","category":"page"},{"location":"phase_modulation/#StructuredLight.zernike_polynomial","page":"Phase Modulation","title":"StructuredLight.zernike_polynomial","text":"zernike_polynomial(x, y, m, n; backend=CPU())\n\nEvaluate the `n` th Zernike polynomial at `(x, y)` with azimuthal order `m`.\n\n\n\n\n\n","category":"function"},{"location":"phase_modulation/#StructuredLight.zernike_polynomial!","page":"Phase Modulation","title":"StructuredLight.zernike_polynomial!","text":"zernike_polynomial!(dest, x, y, m, n)\n\nSame as zernike_polynomial, but writes the result to dest.\n\n\n\n\n\n","category":"function"},{"location":"phase_modulation/#Understanding-Zernike-Indices","page":"Phase Modulation","title":"Understanding Zernike Indices","text":"","category":"section"},{"location":"phase_modulation/","page":"Phase Modulation","title":"Phase Modulation","text":"Zernike polynomials are characterized by two indices:","category":"page"},{"location":"phase_modulation/","page":"Phase Modulation","title":"Phase Modulation","text":"n: radial order (non-negative integer)\nm: azimuthal frequency (integer with |m| ≤ n and n-|m| even)","category":"page"},{"location":"phase_modulation/","page":"Phase Modulation","title":"Phase Modulation","text":"Common aberrations correspond to specific Zernike modes:","category":"page"},{"location":"phase_modulation/","page":"Phase Modulation","title":"Phase Modulation","text":"(n=1, m=±1): Tilt\n(n=2, m=0): Defocus  \n(n=2, m=±2): Astigmatism\n(n=3, m=±1): Coma\n(n=4, m=0): Spherical aberration","category":"page"},{"location":"phase_modulation/#Zernike-Examples","page":"Phase Modulation","title":"Zernike Examples","text":"","category":"section"},{"location":"phase_modulation/","page":"Phase Modulation","title":"Phase Modulation","text":"using StructuredLight, CairoMakie\n\n# Create coordinates\nρ = LinRange(-1, 1, 256)\n\nfunction reject_outside_disk!(dest, ρ)\n    for n ∈ axes(dest, 2), m ∈ axes(dest, 1)\n        if ρ[n]^2 + ρ[m]^2 > 1\n            dest[n, m] = NaN  # Set outside disk to NaN for visualization\n        end\n    end\nend\n\n# Defocus aberration (n=2, m=0)\nZ₂₀ = zernike_polynomial(ρ, ρ, 0, 2)\n\n# Astigmatism (n=2, m=2)\nZ₂₂ = zernike_polynomial(ρ, ρ, 2, 2)\n\n# Coma (n=3, m=1)\nZ₃₁ = zernike_polynomial(ρ, ρ, 1, 3)\n\n# Spherical aberration (n=4, m=0)\nZ₄₀ = zernike_polynomial(ρ, ρ, 0, 4)\n\nfor Z in [Z₂₀, Z₂₂, Z₃₁, Z₄₀]\n    reject_outside_disk!(Z, ρ)\nend\n\n# Visualize the Zernike polynomials\nfig = Figure(size=(800, 750))\nax1 = Axis(fig[1, 1], title=\"Defocus (Z₂₀)\", aspect=1)\nax2 = Axis(fig[1, 2], title=\"Astigmatism (Z₂₂)\", aspect=1)\nax3 = Axis(fig[2, 1], title=\"Coma (Z₃₁)\", aspect=1)\nax4 = Axis(fig[2, 2], title=\"Spherical (Z₄₀)\", aspect=1)\n\nheatmap!(ax1, ρ, ρ, Z₂₀, colormap=:bluesreds)\nheatmap!(ax2, ρ, ρ, Z₂₂, colormap=:bluesreds)\nheatmap!(ax3, ρ, ρ, Z₃₁, colormap=:bluesreds)\nheatmap!(ax4, ρ, ρ, Z₄₀, colormap=:bluesreds)\n\nfig","category":"page"},{"location":"phase_modulation/#General-Phase-Application","page":"Phase Modulation","title":"General Phase Application","text":"","category":"section"},{"location":"phase_modulation/","page":"Phase Modulation","title":"Phase Modulation","text":"The main phase modulation function allows you to apply arbitrary phase corrections defined as linear combinations of basis functions:","category":"page"},{"location":"phase_modulation/","page":"Phase Modulation","title":"Phase Modulation","text":"apply_phase!","category":"page"},{"location":"phase_modulation/#StructuredLight.apply_phase!","page":"Phase Modulation","title":"StructuredLight.apply_phase!","text":"apply_phase!(dest, funcs, coeffs, grid)\n\nApply a phase modulation defined by funcs and coeffs to the array dest.\n\nThe phase modulation consists of multiplying dest by exp(i * φ), where φ is a linear combination of functions funcs with coefficients coeffs evaluated at coordinates defined by grid.\n\ngrid is a tuple of collections, each representing a coordinate axis.\n\nThis function has many applications including aberration correction, lens simulation, phase masks, and general wavefront shaping. The funcs can include zernike_polynomial, lens, or any custom phase functions.\n\nrs = LinRange(-3, 3, 3)\nu = hg(rs, rs)\n\nf1(args) = zernike_polynomial(args..., 1, 1)\nf2(args) = zernike_polynomial(args..., 2, 2)\n\ncoeffs = (0.1, 0.2)\n\napply_phase!(u, (f1, f2), coeffs, (rs, rs))\n\nu\n\n# output\n\n3×3 Matrix{ComplexF64}:\n   1.1609e-8-3.59109e-9im   6.96526e-6+9.82201e-5im    1.1609e-8-3.59109e-9im\n -2.23719e-5-9.58916e-5im     0.797885+0.0im         -2.23719e-5-9.58916e-5im\n   1.1609e-8+3.59109e-9im  -4.97106e-5+8.49974e-5im    1.1609e-8+3.59109e-9im\n\n\n\n\n\n","category":"function"},{"location":"phase_modulation/#Practical-Examples","page":"Phase Modulation","title":"Practical Examples","text":"","category":"section"},{"location":"phase_modulation/","page":"Phase Modulation","title":"Phase Modulation","text":"This is the same example as above, but using the apply_phase! to update a lens phase in place:","category":"page"},{"location":"phase_modulation/","page":"Phase Modulation","title":"Phase Modulation","text":"using StructuredLight, CairoMakie\n\n# Create coordinate grids\nx = LinRange(-4, 4, 512)\ny = LinRange(-4, 4, 512)\nz = LinRange(0, 0.5, 128)\n\n# Generate a Hermite-Gaussian beam\nψ₀ = hg(x, y, m=1, n=1)\n\n# Apply a lens with focal length f=10\nfuncs = (args -> - (args[1]^2 / 0.5 + args[2]^2 / 0.5) / 2,)\ncoeffs = (1,)\n\napply_phase!(ψ₀, funcs, coeffs, (x, y))\n\n# The beam is focused after propagation through the lens\nψ_focused = free_propagation(ψ₀, x, y, z)\n\nsave_animation(abs2.(ψ_focused), \"focused_beam2.mp4\")\n\nnothing # hide","category":"page"},{"location":"phase_modulation/","page":"Phase Modulation","title":"Phase Modulation","text":"(Image: )","category":"page"},{"location":"phase_modulation/","page":"Phase Modulation","title":"Phase Modulation","text":"Here's a complete example showing how to apply multiple phase corrections:","category":"page"},{"location":"phase_modulation/","page":"Phase Modulation","title":"Phase Modulation","text":"using StructuredLight\n\n# Create coordinate system\nrs = LinRange(-3, 3, 256)\ngrid = (rs, rs)\n\n# Generate initial beam\nψ₀ = lg(rs, rs, p=1, l=2)  # Laguerre-Gaussian beam\n\n# Define aberration correction functions using Zernike polynomials\n# Each function takes a tuple of coordinates (x, y)\ndefocus(args) = zernike_polynomial(args..., 0, 2)     # Defocus\nastigmatism(args) = zernike_polynomial(args..., 2, 2) # Astigmatism  \ncoma(args) = zernike_polynomial(args..., 1, 3)        # Coma\n\n# Correction coefficients (in radians of phase)\ncorrection_funcs = (defocus, astigmatism, coma)\ncorrection_coeffs = (0.5, -0.3, 0.2)  # Phase corrections in radians\n\n# Apply corrections to the beam\napply_phase!(ψ₀, correction_funcs, correction_coeffs, grid)\n\nnothing # hide","category":"page"},{"location":"phase_modulation/#Custom-Phase-Functions","page":"Phase Modulation","title":"Custom Phase Functions","text":"","category":"section"},{"location":"phase_modulation/","page":"Phase Modulation","title":"Phase Modulation","text":"You can also define custom phase modulation functions:","category":"page"},{"location":"phase_modulation/","page":"Phase Modulation","title":"Phase Modulation","text":"using StructuredLight # hide\nrs = LinRange(-3, 3, 256) # hide\ngrid = (rs, rs) # hide\nψ_corrected = lg(rs, rs, p=1, l=2) # hide\n\n# Custom quadratic phase (similar to a lens)\nfunction custom_lens(args)\n    x, y = args\n    f = 10.0  # focal length\n    return -(x^2 + y^2) / (2f)  # Quadratic phase\nend\n\n# Apply custom phase modulation\ncustom_correction = (custom_lens,)\ncustom_coeffs = (1.0,)\napply_phase!(ψ_corrected, custom_correction, custom_coeffs, grid)\n\nnothing # hide","category":"page"},{"location":"phase_modulation/#Advanced-Example:-Adaptive-Optics-Simulation","page":"Phase Modulation","title":"Advanced Example: Adaptive Optics Simulation","text":"","category":"section"},{"location":"phase_modulation/","page":"Phase Modulation","title":"Phase Modulation","text":"Here's a more complex example simulating an adaptive optics correction:","category":"page"},{"location":"phase_modulation/","page":"Phase Modulation","title":"Phase Modulation","text":"using StructuredLight\n\n# System parameters\nD = 0.01        # aperture diameter (m)\nrs = LinRange(-D/2, D/2, 512)\n\n# Generate initial beam with aberrations\nψ₀ = lg(rs, rs, p=0, l=1)  # Vortex beam\n\n# Simulate atmospheric turbulence using multiple Zernike modes\nturbulence_modes = [\n    (args) -> zernike_polynomial((args ./ D)..., 0, 2),   # Defocus\n    (args) -> zernike_polynomial((args ./ D)..., 2, 2),   # Astigmatism\n    (args) -> zernike_polynomial((args ./ D)..., 1, 3),   # Coma X\n    (args) -> zernike_polynomial((args ./ D)..., -1, 3),  # Coma Y  \n    (args) -> zernike_polynomial((args ./ D)..., 0, 4),   # Spherical\n]\n\n# Random turbulence strengths\nturbulence_coeffs = 0.1 .* ntuple(n->rand(), 5) \n\n# Apply turbulence\nψ_turbulent = copy(ψ₀)\napply_phase!(ψ_turbulent, turbulence_modes, turbulence_coeffs, (rs, rs))\n\n# Measure aberrations (in practice, this would be done with a wavefront sensor)\nmeasured_coeffs = .-turbulence_coeffs  # Perfect measurement for demo\n\n# Apply correction\nψ_corrected = copy(ψ_turbulent)\napply_phase!(ψ_corrected, turbulence_modes, measured_coeffs, (rs, rs))\n\nnothing # hide","category":"page"},{"location":"propagation/#Propagation","page":"Propagation","title":"Propagation","text":"","category":"section"},{"location":"propagation/","page":"Propagation","title":"Propagation","text":"This package provides a few propagation options. The basic principle is that you give an initial profile and the grid over which it was calculated, and we give back to you the propagated beam. For now, we have included propagation in free space (free_propagation) and in Kerr Media (kerr_propagation).","category":"page"},{"location":"propagation/#free_propagation","page":"Propagation","title":"free_propagation","text":"","category":"section"},{"location":"propagation/","page":"Propagation","title":"Propagation","text":"free_propagation","category":"page"},{"location":"propagation/#StructuredLight.free_propagation","page":"Propagation","title":"StructuredLight.free_propagation","text":"free_propagation(ψ, x, y, z [, scaling]; k=1)\n\nPropagate an inital profile ψ.\n\nThe propagation is the solution of ∇² ψ + 2ik ∂_z ψ = 0 at distance z under the initial condition ψ.\n\nx and y are the grids over which ψ is calculated.\n\nIf z is an AbstractArray, the output is a 3D array representing the solution at every element of z.\n\nThe output at a distance z[n] is calculated on a scalled grid defined by scaling[n] * x and scaling[n] * y.\n\nk is the wavenumber.\n\nExample\n\nx = LinRange(-10, 10, 256)\ny = LinRange(-10, 10, 512)\nz = LinRange(0.1, 1, 10)\n\nψ = hg(x, y; m=3, n=2)\nψ′ = hg(2x, 2y; m=3, n=2)\n\n(\n    free_propagation(ψ, x, y, z) ≈ stack(free_propagation(ψ, x, y, z) for z ∈ z)\n    &&\n    free_propagation(ψ, x, y, z, fill(2, length(z))) ≈ stack(free_propagation(ψ, x, y, z, 2) for z ∈ z)\n    &&\n    free_propagation(ψ, x, y, 0.5, 2) ≈ free_propagation(ψ′, 2x, 2y, 0.5)\n)\n\n# output\n\ntrue\n\n\n\n\n\n","category":"function"},{"location":"propagation/#Examples:","page":"Propagation","title":"Examples:","text":"","category":"section"},{"location":"propagation/","page":"Propagation","title":"Propagation","text":"#The simplest usage would be the following:\r\nusing StructuredLight, CairoMakie\r\n\r\nrs = LinRange(-6,6,256)\r\n\r\n#Here we define an initial profile that isn't invariant upon propagation.\r\nψ₀ = lg(rs,rs) / 2 + lg(rs,rs,p=1)\r\n\r\nψ = free_propagation(ψ₀,rs,rs,1) #Then, we propagate it by a distance z=1.\r\n\r\n#Here are the initial profiles the propagated beam, side by side.\r\nvisualize([ψ₀,ψ] |> stack .|> abs2)","category":"page"},{"location":"propagation/","page":"Propagation","title":"Propagation","text":"#We can also provide a collection of z values to produce an animation:\r\nusing StructuredLight, CairoMakie\r\n\r\nrs = LinRange(-12,12,256)\r\nzs = LinRange(0,1,64)\r\n\r\n#This is a laguerre-gaussian modulated by a sine function.\r\nψ₀ = lg(rs,rs,l=2,p=1) .* map(r->sin(6*r[2]),Iterators.product(rs,rs))\r\n\r\n#Now the propagation is performed for each z ∈ zs. The output is a 3D array.\r\nψs = free_propagation(ψ₀,rs,rs,zs)\r\n\r\nsave_animation(abs2.(ψs), \"lg_times_sin.mp4\")\r\n\r\nnothing # hide","category":"page"},{"location":"propagation/","page":"Propagation","title":"Propagation","text":"(Image: )","category":"page"},{"location":"propagation/","page":"Propagation","title":"Propagation","text":"using StructuredLight, CairoMakie\r\n\r\nrs = LinRange(-4, 4, 256)\r\nzs = LinRange(0.01, 1, 32)\r\n\r\n#This is a gaussian mode\r\nψ₀ = lg(rs, rs)\r\nscalings = @. √(1 + 4 * zs^2) #Here, we introduce the scalings given by w(z)/w0\r\n\r\n#Now we propagate, including the scalings\r\nψs = free_propagation(ψ₀, rs, rs, zs, scalings)\r\n\r\n#Note that the scalings compensate the diffraction of the beam.\r\n#Therefore, the animation seems still.\r\nsave_animation(abs2.(ψs), \"standing_still.mp4\")\r\n\r\nnothing # hide","category":"page"},{"location":"propagation/","page":"Propagation","title":"Propagation","text":"(Image: )","category":"page"},{"location":"propagation/#References","page":"Propagation","title":"References","text":"","category":"section"},{"location":"propagation/","page":"Propagation","title":"Propagation","text":"The book \"Schmidt, J. D. (2010). Numerical Simulation of Optical Wave Propagation with Examples in MATLAB. United States: SPIE.\" is a great resource to learn about numerical propagation of paraxial light beams","category":"page"},{"location":"propagation/#kerr_propagation","page":"Propagation","title":"kerr_propagation","text":"","category":"section"},{"location":"propagation/#Theoretical-Background","page":"Propagation","title":"Theoretical Background","text":"","category":"section"},{"location":"propagation/#The-Nonlinear-Schrödinger-Equation","page":"Propagation","title":"The Nonlinear Schrödinger Equation","text":"","category":"section"},{"location":"propagation/","page":"Propagation","title":"Propagation","text":"Kerr propagation describes how optical beams evolve in nonlinear media where the refractive index depends on the light intensity. This is governed by the nonlinear Schrödinger equation (NLSE):","category":"page"},{"location":"propagation/","page":"Propagation","title":"Propagation","text":"i ∂ψ/∂z + (1/2k) ∇²⊥ψ + g|ψ|²ψ = 0","category":"page"},{"location":"propagation/","page":"Propagation","title":"Propagation","text":"where:","category":"page"},{"location":"propagation/","page":"Propagation","title":"Propagation","text":"ψ(x,y,z) is the slowly-varying envelope of the optical field\nk is the wavenumber \ng is the nonlinear coefficient (related to the Kerr nonlinearity)\n∇² is the transverse Laplacian operator","category":"page"},{"location":"propagation/#Physical-Effects","page":"Propagation","title":"Physical Effects","text":"","category":"section"},{"location":"propagation/","page":"Propagation","title":"Propagation","text":"Self-focusing: In materials with positive Kerr nonlinearity (g > 0), regions of high intensity experience a higher refractive index, creating a \"self-induced lens\" that focuses the beam. This can lead to:","category":"page"},{"location":"propagation/","page":"Propagation","title":"Propagation","text":"Beam collapse: Strong nonlinearity can cause catastrophic focusing\nSoliton formation: Balance between diffraction and self-focusing creates stable pulses\nFilamentation: Beam breakup into multiple filaments","category":"page"},{"location":"propagation/","page":"Propagation","title":"Propagation","text":"Self-defocusing: For negative Kerr nonlinearity (g < 0), high-intensity regions have lower refractive index, causing beam spreading.","category":"page"},{"location":"propagation/#Numerical-Implementation","page":"Propagation","title":"Numerical Implementation","text":"","category":"section"},{"location":"propagation/","page":"Propagation","title":"Propagation","text":"The kerr_propagation function uses a split-step Fourier method:","category":"page"},{"location":"propagation/","page":"Propagation","title":"Propagation","text":"Linear step: Apply diffraction in Fourier domain\nNonlinear step: Apply self-phase modulation in real space\nRepeat: Alternate steps for small z increments","category":"page"},{"location":"propagation/","page":"Propagation","title":"Propagation","text":"The g parameter controls the nonlinear strength: larger values lead to stronger self-focusing effects.","category":"page"},{"location":"propagation/","page":"Propagation","title":"Propagation","text":"kerr_propagation","category":"page"},{"location":"propagation/#StructuredLight.kerr_propagation","page":"Propagation","title":"StructuredLight.kerr_propagation","text":"kerr_propagation(ψ₀,xs,ys,zs,total_steps;k=1,g=1)\n\nSolve ∇² ψ + 2ik ∂_z ψ = - g |ψ|² ψ under the initial condition ψ₀.\n\nxs and ys are the grids over which ψ₀ is calculated.\n\nThe outputs are saved at every zs, which is a number or a collection of numbers.\n\ntotal_steps is the number of steps over which we discretize the propagation. The larger the total_steps, the better the precision and the slower is the calculation.\n\n\n\n\n\n","category":"function"},{"location":"propagation/#Example","page":"Propagation","title":"Example","text":"","category":"section"},{"location":"propagation/","page":"Propagation","title":"Propagation","text":"using StructuredLight, CairoMakie\r\n\r\nrs = LinRange(-2.5,2.5,256) #The transverse grid\r\nzs = LinRange(0,.12,32) #The z grid\r\n\r\nψ₀ = lg(rs,rs) #Calculates the fundamental Laguerre-Gaussian mode\r\n\r\n#We perform the propagation with a strong nonlinearity\r\nψ = kerr_propagation(ψ₀,rs,rs,zs,512,g=200)\r\n\r\nsave_animation(abs2.(ψ), \"kerr.mp4\") #The beam colapses due to the self focusing effect\r\n\r\nnothing # hide","category":"page"},{"location":"propagation/","page":"Propagation","title":"Propagation","text":"(Image: )","category":"page"},{"location":"propagation/#References-2","page":"Propagation","title":"References","text":"","category":"section"},{"location":"propagation/","page":"Propagation","title":"Propagation","text":"The package NonlinearSchrodinger.jl has more available solvers for this equation, but, as far as I can see, it only works with one spatial dimensional. Its author has also written a paper that explains the theory that goes behind the numerical solution. I have also written the package GeneralizedGrossPitaevskii.jl that implements the propagation described by a generalized Gross-Pitaevskii equation over arbitrary dimensions.","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Mode-Converter","page":"Examples","title":"Mode Converter","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this example, we reproduce the results of Beijersbergen, Marco W., et al. \"Astigmatic laser mode converters and transfer of orbital angular momentum.\" Optics Communications 96.1-3 (1993): 123-132., where it is shown that a tilted lens can \"transform\" a Laguerre-Gauss mode in a diagonal Hermite-Gauss mode.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using StructuredLight, CairoMakie\r\nk = 1\r\nf = √2\r\nd = f / √2\r\nw = √((2 + √2) * f / k)\r\nrs = LinRange(-4w, 4w, 512)\r\nzs = LinRange(0, 2d, 64)\r\n\r\nψ₀ = lg(rs, rs, -d; w, k, l=1, p=0) .* lens(rs, rs, Inf, f; k)\r\nψ₁ = free_propagation(ψ₀, rs, rs, 2d; k)\r\nψs = free_propagation(ψ₀, rs, rs, zs; k)\r\n\r\nvisualize(abs2.([ψ₀, ψ₁] |> stack))","category":"page"},{"location":"examples/#Astigmatic-Conversion","page":"Examples","title":"Astigmatic Conversion","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this example, we reproduce the results of Pravin Vaity et al., \"Measuring topological charge of optical vortices using a tilted convex lens,\" Phys. Lett. A, vol. 377, no. 15, pp. 1154-1156, 2013. DOI: 10.1016/j.physleta.2013.02.030, where it is shown that a tilted lens can \"transform\" a Laguerre-Gauss mode in a diagonal Hermite-Gauss mode.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using StructuredLight, CairoMakie\r\n\r\n#All quantities have unit of (inverse) meter\r\n\r\nw = 0.16e-3 #Waist\r\nλ = 632.8e-9 #Wavelength\r\nk = 2π / λ #Wavenumber\r\nf = 50e-2 #Focal length of the lens\r\n\r\nz₀ = 3.1 #Distance away from the focus where the beam encounters the lens\r\n\r\nz_cr = z₀ / (z₀ / f - 1) #Conversion distance\r\n\r\nξ = deg2rad(6) #Tilting angle\r\n\r\n# Now, we set up our grid and the initial profile by including the action of a tilted lens:\r\nrs = LinRange(-70w, 70w, 1024)\r\nψ₀ = lg(rs, rs, z₀, l=3; w, k) .* tilted_lens(rs, rs, f, ξ; k) #Applies the lens\r\n\r\n# Finally, we propagate. \r\n# Note that we introduce scalings, because, otherwise, the beam would be to small.\r\nzs = z_cr .* LinRange(0.97, 1.03, 64)\r\nscalings = 0.015 .* vcat(LinRange(2.4, 1, 32), LinRange(1, 2.4, 32))\r\nψ = free_propagation(ψ₀, rs, rs, zs, k=k, scalings)\r\nanim = save_animation(abs2.(ψ), \"tilted_lens.mp4\", framerate=12)\r\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"By changing the initial angular momentum, one obtains different HG modes.","category":"page"},{"location":"examples/#Diffraction-of-vortices-through-a-triangular-aperture","page":"Examples","title":"Diffraction of vortices through a triangular aperture","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"See B. Pinheiro da Silva, G. H. dos Santos, A. G. de Oliveira, N. Rubiano da Silva, W. T. Buono, R. M. Gomes, W. C. Soares, A. J. Jesus-Silva, E. J. S. Fonseca, P. H. Souto Ribeiro, and A. Z. Khoury, \"Observation of a triangular-lattice pattern in nonlinear wave mixing with optical vortices,\" Optica 9, 908-912 (2022)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using StructuredLight, CairoMakie\r\nxs = LinRange(-16, 16, 512)\r\nys = LinRange(-16, 16, 512)\r\nzs = LinRange(0, 0.6, 64)\r\n\r\n# Create initial beam with triangular aperture\r\ninitial_beam = lg(xs, ys, l=3)\r\ntriangular_mask = triangle(xs, ys, 3.0)\r\nshaped_initial = initial_beam .* triangular_mask\r\n\r\n# Propagate the shaped beam\r\npropagated = free_propagation(shaped_initial, xs, ys, zs)\r\nsave_animation(abs2.(propagated), \"shaped_beam_prop.mp4\")\r\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Diffraction-Rings-in-Kerr-Media","page":"Examples","title":"Diffraction Rings in Kerr Media","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Here, we reproduce the results of E. V. Garcia Ramirez, M. L. Arroyo Carrasco, M. M. Mendez Otero, S. Chavez Cerda, and M. D. Iturbe Castillo, \"Far field intensity distributions due to spatial self phase modulation of a Gaussian beam by a thin nonlocal nonlinear media,\" Opt. Express 18, 22067-22079 (2010), where it is studied the appearance of rings in the far field profile of a Gaussian beam after it crosses a nonlinear medium.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"#First we import the package.\r\nusing StructuredLight, CairoMakie\r\n\r\n#Define a function that calculates the nonlinear phase term.\r\nfunction non_linear_phase(ψ,m,n)\r\n    M = maximum(abs2,ψ)\r\n    [ cis( π * n * (abs2(ψ[j,k])/M)^(m/2) ) for j ∈ axes(ψ,1), k ∈ axes(ψ,2) ]\r\nend\r\n\r\n#Define a function that calculates the three images.\r\nfunction get_images(rs,ms,n,z₀,z,scalling)\r\n    ψ = Array{ComplexF64}(undef,length(rs),length(rs),length(ms))\r\n\r\n    ψ₀ = lg(rs,rs,z₀)\r\n\r\n    for (i,m) in enumerate(ms)\r\n        ψ₁ = ψ₀ .* non_linear_phase(ψ₀,m,n)\r\n        ψ[:,:,i] = free_propagation(ψ₁,rs,rs,z,scalling)\r\n    end\r\n\r\n    ψ\r\nend\r\n\r\n#The values of `m` that are used throughout the article:\r\nms = (1,2,4)\r\n\r\n#The Rayleigh range:\r\nzᵣ = 1/2;\r\n\r\n# This would be the figure 1:\r\nrs = LinRange(-10,10,512)\r\nvisualize(abs2.(get_images(rs,ms,2,-4zᵣ,15,10)))","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The other figures are just a variation of this one, by changing the distance from the waist and n.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Alternatively, we can solve the complete nonlinear Schrödinger equation to get the initial profile:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using StructuredLight, CairoMakie\r\nrs = LinRange(-10,10,512)\r\nzᵣ = 1/2\r\nψ₀ = lg(rs,rs,-4zᵣ)\r\nM = maximum(abs2,ψ₀)\r\n\r\nn = 2\r\nψ₁ = kerr_propagation(ψ₀,rs,rs,.01*zᵣ,512,g=400*n*π/M)\r\n\r\n#The output of this free propagation should then be equal to the previous case with `m=2`:\r\nψ = free_propagation(ψ₁,rs,rs,10,7)\r\nvisualize(abs2.(ψ))","category":"page"},{"location":"miscellany/#Miscellany","page":"Miscellany","title":"Miscellany","text":"","category":"section"},{"location":"miscellany/","page":"Miscellany","title":"Miscellany","text":"Here we show a few small functionalities that didn't fit anywhere else.","category":"page"},{"location":"miscellany/","page":"Miscellany","title":"Miscellany","text":"overlap","category":"page"},{"location":"miscellany/#StructuredLight.overlap","page":"Miscellany","title":"StructuredLight.overlap","text":"overlap(ψ₁,ψ₂,xs,ys)\n\nCalculate ∫ ψ₁ conj(ψ₂) dx dy.\n\nxs and ys are the grids over which ψ₁ and ψ₂ are calculated.\n\n\n\n\n\noverlap(ψ₁::AbstractArray{T1,3},ψ₂::AbstractArray{T2,3},xs,ys) where {T1,T2}\n\nCalculate ∫ ψ₁[:,:,j] conj(ψ₂[:,:,j]) dx dy, where j runs over all indices of the third dimension. \n\nThe output is a vector.\n\nxs and ys are the grids over which ψ₁ and ψ₂ are calculated.\n\n\n\n\n\n","category":"function"},{"location":"miscellany/","page":"Miscellany","title":"Miscellany","text":"using StructuredLight, CairoMakie\r\n\r\nrs = LinRange(-5,5,256) \r\nψ₁ = hg(rs,rs)\r\nψ₂ = hg(rs,rs,m=1)\r\n\r\noverlap(ψ₁,ψ₁,rs,rs) #The modes are normalized\r\noverlap(ψ₁,ψ₂,rs,rs) #Modes with different indices are orthogonal\r\n\r\nzs = LinRange(0,.5,8)\r\nψ₁s = free_propagation(ψ₁,rs,rs,zs)\r\nψ₂s = free_propagation(ψ₂,rs,rs,zs)\r\n\r\n# Free propagation is an unitary transformation\r\n# Therefore, it preserves the overlap\r\noverlap(ψ₁s,ψ₁s,rs,rs), overlap(ψ₁s,ψ₂s,rs,rs) ","category":"page"},{"location":"gpu_support/#GPU-Support","page":"GPU Support","title":"GPU Support","text":"","category":"section"},{"location":"gpu_support/","page":"GPU Support","title":"GPU Support","text":"StructuredLight.jl provides GPU acceleration through KernelAbstractions.jl, enabling high-performance computations for large-scale optical simulations.","category":"page"},{"location":"gpu_support/","page":"GPU Support","title":"GPU Support","text":"StructuredLight.jl provides GPU support through two complementary approaches:","category":"page"},{"location":"gpu_support/","page":"GPU Support","title":"GPU Support","text":"Backend parameter: Functions like lg(), hg(), and zernike_polynomial() accept a backend keyword argument (e.g., CUDABackend()) to generate arrays directly on the specified device.\nAutomatic dispatch: Functions like free_propagation() and generate_hologram(), or functions that operate in place automatically detect GPU arrays in their inputs and execute on the same device, providing seamless GPU execution without explicit backend specification.","category":"page"},{"location":"gpu_support/#GPU-Accelerated-Functions","page":"GPU Support","title":"GPU-Accelerated Functions","text":"","category":"section"},{"location":"gpu_support/","page":"GPU Support","title":"GPU Support","text":"All major computational functions support GPU execution:","category":"page"},{"location":"gpu_support/","page":"GPU Support","title":"GPU Support","text":"Beam Profiles: hg(), lg(), diagonal_hg() - Support backend parameter\nBeam Manipulation: grid_linear_combination() - Automatic GPU dispatch\nPropagation: free_propagation(), kerr_propagation() - Automatic GPU dispatch  \nHolograms: generate_hologram() - Both BesselJ1() and Simple() methods with automatic GPU dispatch for in-place version and backend parameter for out-of-place version\nPhase Modulation: zernike_polynomial() - Support backend parameter","category":"page"},{"location":"gpu_support/#Supported-Backends","page":"GPU Support","title":"Supported Backends","text":"","category":"section"},{"location":"gpu_support/","page":"GPU Support","title":"GPU Support","text":"Fully Tested and Supported:","category":"page"},{"location":"gpu_support/","page":"GPU Support","title":"GPU Support","text":"CUDA: NVIDIA GPUs - Works flawlessly with comprehensive testing","category":"page"},{"location":"gpu_support/","page":"GPU Support","title":"GPU Support","text":"Known Issues:","category":"page"},{"location":"gpu_support/","page":"GPU Support","title":"GPU Support","text":"Metal: Apple Silicon GPUs - Tested but currently not working due to known compatibility issues","category":"page"},{"location":"gpu_support/","page":"GPU Support","title":"GPU Support","text":"Theoretical Support (Untested):","category":"page"},{"location":"gpu_support/","page":"GPU Support","title":"GPU Support","text":"ROCm: AMD GPUs - Untested, may work through KernelAbstractions\noneAPI: Intel GPUs - Untested, may work through KernelAbstractions","category":"page"},{"location":"gpu_support/#Basic-CUDA-Usage","page":"GPU Support","title":"Basic CUDA Usage","text":"","category":"section"},{"location":"gpu_support/#Method-1:-Using-Backend-Parameter","page":"GPU Support","title":"Method 1: Using Backend Parameter","text":"","category":"section"},{"location":"gpu_support/","page":"GPU Support","title":"GPU Support","text":"using StructuredLight, CUDA\n\n# Generate beam profile directly on GPU\nrs = LinRange(-5, 5, 1024)\nψ₀ = lg(rs, rs, backend=CUDABackend())\n\n# The result is automatically a CuArray\ntypeof(ψ₀) # CuArray{ComplexF64, 2, ...}","category":"page"},{"location":"gpu_support/#Method-2:-Automatic-Dispatch","page":"GPU Support","title":"Method 2: Automatic Dispatch","text":"","category":"section"},{"location":"gpu_support/","page":"GPU Support","title":"GPU Support","text":"using StructuredLight, CUDA\n\nrs = LinRange(-5, 5, 1024)\nψ₀ = lg(rs, rs, backend=CUDABackend())\n\n# Propagation automatically runs on GPU via multiple dispatch\nzs = LinRange(0, 1, 32)\nψs = free_propagation(ψ₀, rs, rs, zs)","category":"page"},{"location":"gpu_support/#Advanced-Examples","page":"GPU Support","title":"Advanced Examples","text":"","category":"section"},{"location":"gpu_support/#Large-Scale-Beam-Propagation","page":"GPU Support","title":"Large-Scale Beam Propagation","text":"","category":"section"},{"location":"gpu_support/","page":"GPU Support","title":"GPU Support","text":"using StructuredLight, CUDA, CairoMakie\n\n# High-resolution grid for detailed simulation\nxs = LinRange(-12, 12, 1024)\nys = LinRange(-12, 12, 1024)\nzs = LinRange(0, 0.2, 100)\n\n# Generate complex beam pattern on GPU\ninitial_beam = lg(xs, ys, p=2, l=3, backend=CUDABackend())\n\n# Apply beam shaping\naperture = pupil(xs, ys, 1.0)\nshaped_beam = initial_beam .* CuArray(aperture)\n\n# High-resolution propagation \npropagated = free_propagation(shaped_beam, xs, ys, zs)\n\n# Transfer back to CPU for visualization\nsave_animation(abs2.(Array(propagated)), \"gpu_propagation.mp4\")","category":"page"},{"location":"gpu_support/#GPU-Beam-Superposition","page":"GPU Support","title":"GPU Beam Superposition","text":"","category":"section"},{"location":"gpu_support/","page":"GPU Support","title":"GPU Support","text":"using StructuredLight, CUDA\n\nrs = LinRange(-4, 4, 512)\ngrid = (rs, rs)\n\n# Define component functions\nf1(args) = hg(args..., m=1, n=0)\nf2(args) = hg(args..., m=0, n=1) \nf3(args) = lg(args..., p=0, l=1)\n\nfuncs = (f1, f2, f3)\ncoeffs = (0.5, 0.5, 0.7im)\n\n# Create superposition on GPU\nsuperposition = grid_linear_combination(funcs, coeffs, grid, backend=CUDABackend())","category":"page"},{"location":"gpu_support/#GPU-Hologram-Generation","page":"GPU Support","title":"GPU Hologram Generation","text":"","category":"section"},{"location":"gpu_support/","page":"GPU Support","title":"GPU Support","text":"using StructuredLight, CUDA\n\n# Create target beam on GPU\nx = LinRange(-5, 5, 256)\ny = LinRange(-5, 5, 256)\ntarget_beam = lg(x, y, l=2) |> cu\n\n# Generate hologram on GPU - both methods supported\nhologram_bessel = generate_hologram(target_beam, 255, 2, 2, BesselJ1())\nhologram_simple = generate_hologram(target_beam, 255, 2, 2, Simple())\n\n# Results are CuArrays\ntypeof(hologram_bessel) # CuArray{UInt8, 2, ...}","category":"page"},{"location":"quick_start/#Quick-Start","page":"Quick Start","title":"Quick Start","text":"","category":"section"},{"location":"quick_start/#What-is-StructuredLight.jl?","page":"Quick Start","title":"What is StructuredLight.jl?","text":"","category":"section"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"StructuredLight.jl is a Julia package for simulating structured optical beams - light fields with complex spatial patterns like orbital angular momentum, customizable intensity profiles, and controlled phase distributions. The package enables:","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"Generation of standard beam modes (Laguerre-Gaussian, Hermite-Gaussian)\nBeam propagation through free space and nonlinear media\nApplication of optical elements (lenses, apertures, phase masks)\nCreation of computer-generated holograms for producing these beams in the lab\nVisualization and analysis of beam evolution","category":"page"},{"location":"quick_start/#Installation","page":"Quick Start","title":"Installation","text":"","category":"section"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"To install the StructuredLight package, you can use the Julia package manager. Open the Julia REPL type ] to enter the package manager mode, and then run:","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"add StructuredLight","category":"page"},{"location":"quick_start/#Basic-Examples","page":"Quick Start","title":"Basic Examples","text":"","category":"section"},{"location":"quick_start/#Example-1:-Creating-and-Visualizing-a-Gaussian-Beam","page":"Quick Start","title":"Example 1: Creating and Visualizing a Gaussian Beam","text":"","category":"section"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"Let's start with the simplest case - a fundamental Gaussian beam:","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"using StructuredLight\n\n# Define spatial coordinates (in arbitrary units)\n# This creates a 2D grid from -5 to +5 with 256 points in each direction\nspatial_range = LinRange(-3, 3, 256)\n\n# Create a fundamental Gaussian beam (Laguerre-Gaussian with l=0, p=0)\n# The beam is evaluated at the focal plane (z=0)\ngaussian_beam = lg(spatial_range, spatial_range)\n\n# Visualize the intensity profile\nusing CairoMakie\nvisualize(abs2.(gaussian_beam))","category":"page"},{"location":"quick_start/#Example-2:-Beam-Propagation","page":"Quick Start","title":"Example 2: Beam Propagation","text":"","category":"section"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"Now let's see how this beam evolves as it propagates through space:","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"using StructuredLight, CairoMakie\n\n# Define spatial grid\nspatial_range = LinRange(-5, 5, 256)\n\n# Create initial Gaussian beam at focus (z=0)\n# We use the same spatial range for both x and y coordinates\ninitial_beam = lg(spatial_range, spatial_range)\n\n# Propagate the beam to distance z=1\n# Here we assume that the wavenumber k=1 for simplicity. This can be adjusted with a keyword argument `k`.\npropagated_beam = free_propagation(initial_beam, spatial_range, spatial_range, 1)\n\n# Compare initial and propagated beams side by side\nfig = Figure(size = (800, 400))\nax1 = Axis(fig[1,1], title=\"At focus (z=0)\")\nax2 = Axis(fig[1,2], title=\"Propagated (z=1)\")\n\nheatmap!(ax1, abs2.(initial_beam), colormap = :jet)\nheatmap!(ax2, abs2.(propagated_beam), colormap = :jet)\n\nfig","category":"page"},{"location":"quick_start/#Example-3:-Vortex-Beam-with-Orbital-Angular-Momentum","page":"Quick Start","title":"Example 3: Vortex Beam with Orbital Angular Momentum","text":"","category":"section"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"One of the most studied structured light beams are the ones carrying orbital angular momentum:","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"using StructuredLight, CairoMakie\n\nspatial_range = LinRange(-5, 5, 256)\n\n# Create a vortex beam with topological charge l=3\n# This beam carries 3ℏ orbital angular momentum per photon\nvortex_beam = lg(spatial_range, spatial_range, l=3)\n\n# Show both intensity and phase\nfig = Figure(size = (800, 400))\nax1 = Axis(fig[1,1], title=\"Intensity |ψ|²\")\nax2 = Axis(fig[1,2], title=\"Phase arg(ψ)\")\n\nheatmap!(ax1, abs2.(vortex_beam), colormap = :jet)\nheatmap!(ax2, angle.(vortex_beam), colormap = :hsv)\n\nfig","category":"page"},{"location":"quick_start/#Example-4:-Beam-Shaping-with-Apertures","page":"Quick Start","title":"Example 4: Beam Shaping with Apertures","text":"","category":"section"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"You can shape beams using various apertures and masks:","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"using StructuredLight, CairoMakie\n\nspatial_range = LinRange(-4, 4, 256)\n\n# Create a vortex beam\nbeam = lg(spatial_range, spatial_range, l=2)\n\n# Apply different apertures\ntriangular_aperture = triangle(spatial_range, spatial_range, 3.0)\nsquare_aperture = square(spatial_range, spatial_range, 2.0)\n\n# Shape the beam with apertures\ntriangular_beam = beam .* triangular_aperture\nsquare_beam = beam .* square_aperture\n\n# Visualize all variants\nfig = Figure(size = (1200, 400))\nax1 = Axis(fig[1,1], title=\"Original vortex\")\nax2 = Axis(fig[1,2], title=\"Triangular aperture\")\nax3 = Axis(fig[1,3], title=\"Square aperture\")\n\nheatmap!(ax1, abs2.(beam), colormap = :jet)\nheatmap!(ax2, abs2.(triangular_beam), colormap = :jet)\nheatmap!(ax3, abs2.(square_beam), colormap = :jet)\n\nfig","category":"page"},{"location":"quick_start/#Coordinate-System-and-Grid-Setup","page":"Quick Start","title":"Coordinate System and Grid Setup","text":"","category":"section"},{"location":"quick_start/#Understanding-Spatial-Grids","page":"Quick Start","title":"Understanding Spatial Grids","text":"","category":"section"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"StructuredLight.jl uses Cartesian coordinate systems where:","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"Coordinates: (x, y) represent transverse spatial coordinates  \nUnits: All spatial quantities use consistent units (usually arbitrary units, but can represent physical distances)","category":"page"},{"location":"quick_start/#Physical-Interpretation","page":"Quick Start","title":"Physical Interpretation","text":"","category":"section"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"# Arbitrary units - could represent any length scale\nspatial_range = LinRange(-2.5, 2.5, 256)\n\n# Physical units example (e.g., millimeters):\nx_mm = LinRange(-5.0, 5.0, 256)  # 10mm total width","category":"page"},{"location":"quick_start/#Common-Conventions","page":"Quick Start","title":"Common Conventions","text":"","category":"section"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"Beam waist: Usually placed at z=0 (focal plane)\nPropagation direction: Positive z-axis by convention\nAngular coordinates: For lg() modes, azimuthal angle measured from positive x-axis","category":"page"},{"location":"quick_start/#Key-Concepts","page":"Quick Start","title":"Key Concepts","text":"","category":"section"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"Spatial grid: Define your coordinate system using some sort of range to specify the spatial extent and resolution. Here we use LinRange\nBeam modes: Use lg() for Laguerre-Gaussian modes (circular symmetry, orbital angular momentum), hg() for Hermite-Gaussian modes (rectangular symmetry), or any other custom modes\nPropagation: Use free_propagation() to evolve beams through free space\nVisualization: The visualize() function provides quick plotting, and requires loading CairoMakie","category":"page"},{"location":"quick_start/#Next-Steps","page":"Quick Start","title":"Next Steps","text":"","category":"section"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"Explore Beam Profiles for detailed mode generation\nDive into Visualization for learning some predefined plotting techniques\nLearn about Propagation for advanced beam evolution\nCheck Holograms for creating computer-generated holograms in order to produce structured light beams in the lab\nVisit Phase Modulation for optical element simulation\nSee the examples page for complete applications and research reproductions","category":"page"},{"location":"visualization/#Visualization","page":"Visualization","title":"Visualization","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"This package offer tools that help the visualization of the generated beams. They are built on top of the CairoMakie package, which is a powerful plotting library in Julia. It needs to be installed separately and loaded with using CairoMakie before using the visualization functions.","category":"page"},{"location":"visualization/#visualize","page":"Visualization","title":"visualize","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"The simplest of such tools is the visualize function, which displays the beam as a static image. It accepts two, three and four dimensional arrays. The first two dimensions are interpreted as the spatial coordinates, the third dimension is interpreted as different rows of images, and the fourth dimension is interpreted as different columns of images.","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"visualize","category":"page"},{"location":"visualization/#StructuredLight.visualize","page":"Visualization","title":"StructuredLight.visualize","text":"visualize(img;\ncolormap=:jet, colorrange=Makie.automatic,\nshare_colorrange=false, scaling=1)\n\nVizualize the image(s) img.\n\nimg can be a 2D, 3D or 4D array.\n\nWhen using the 3D Array signature, the third dimension is interpreted as defining different images, which are displayed in a row.\n\nWhen using the 4D Array signature, the third and fourth dimensions are interpreted as defining different images, which are displayed in a matrix.\n\nkeyword arguments\n\ncolormap defines the colormap of the image(s).\n\nscaling defines the maximum side length of the image, which is passed to Makie.Figure.\n\nshare_colorrange defines if the color range should be shared between all images. Has no effect for the 2D Array signature.\n\ncolorrange defines the color range of the image(s).\n\n\n\n\n\n","category":"function"},{"location":"visualization/#Example:","page":"Visualization","title":"Example:","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"using StructuredLight, CairoMakie\n\nrs = LinRange(-4,4,256) \n\nψ₁ = stack( [diagonal_hg(rs,rs,m=3), diagonal_hg(rs,rs,n=3)] )\n\nψ₂ = stack( [hg(rs,rs,m=3), hg(rs,rs,n=3)] )\n\nvisualize(abs2.(ψ₁)) #Displays ψ₁ \n\nvisualize(abs2.(ψ₂)) #Displays ψ₂\n\nψ₃ = stack([ψ₁,ψ₂])\n\nvisualize(abs2.(ψ₃)) #Displays ψ₁ and ψ₂ in a row.","category":"page"},{"location":"visualization/#save_animation","page":"Visualization","title":"save_animation","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"With three-dimensional arrays, which are interpreted as a sequence of 2D images, we can also form animations. save_animation will save the animation on the given path. This is useful for visualizing the evolution of beams as they propagate through space or interact with different apertures.","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"save_animation","category":"page"},{"location":"visualization/#StructuredLight.save_animation","page":"Visualization","title":"StructuredLight.save_animation","text":"save_animation(img::AbstractArray{T,3}, path;\ncolormap=:jet, share_colorrange=false, scaling=1, framerate=16) where {T<:Real}\n\nSave an animation of img at path with a framerate.\n\nThe colors are given by colormap.\n\nscaling defines the maximum side length of the image, which is passed to Makie.Figure.\n\nshare_colorrange defines if the color range should be shared between all images.\n\n\n\n\n\n","category":"function"},{"location":"visualization/#Example:-2","page":"Visualization","title":"Example:","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"using StructuredLight, CairoMakie\n\nrs = LinRange(-6,6,256) \nzs = LinRange(0,1,32)\n\nψ₀ = hg(rs,rs) + hg(rs,rs,n=2)/√2\n\nψs = free_propagation(ψ₀,rs,rs,zs)\n\nsave_animation(abs2.(ψs),\"animation.mp4\",framerate=12)\n\nnothing # hide","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"(Image: )","category":"page"},{"location":"beam_profiles/#Beam-Profiles","page":"Beam Profiles","title":"Beam Profiles","text":"","category":"section"},{"location":"beam_profiles/","page":"Beam Profiles","title":"Beam Profiles","text":"This package implements the Laguerre-Gauss modes (lg), the Hermite-Gauss modes (hg) and its diagonal version (diagonal_hg).","category":"page"},{"location":"beam_profiles/","page":"Beam Profiles","title":"Beam Profiles","text":"In all cases, one must specify the points or the grids over which the mode is calculated. The other beam parameters are specified through keyword arguments.","category":"page"},{"location":"beam_profiles/#Laguerre-Gauss","page":"Beam Profiles","title":"Laguerre-Gauss","text":"","category":"section"},{"location":"beam_profiles/","page":"Beam Profiles","title":"Beam Profiles","text":"lg\r\nlg!\r\nnormalization_lg","category":"page"},{"location":"beam_profiles/#StructuredLight.lg","page":"Beam Profiles","title":"StructuredLight.lg","text":"lg(x, y, z=zero(eltype(x)); p=0, l=0, w=one(eltype(x)), k=one(eltype(x)), N=normalization_lg(p, l, w), backend=CPU())\n\nCompute a Laguerre-Gaussian mode.\n\nx, y and z can be numbers or collections, but x and y must be always of the same kind.\n\nOther Arguments:\n\np: radial index\nl: topological charge\nw: beam's waist\nk: wavenumber\nN: normalization constant. The default value computed by normalization_lg ensures that the integral of the absolute square of mode is equal to 1.\nbackend: backend to use for the computation, as defined in KernelAbstractions. Default is CPU(). You can use e.g., CUDABackend(), MetalBackend(), ROCBackend() or oneAPIBackend() for GPU computations.\n\nThe formula is given by:\n\npsi_pl(xyz) = N_pl alpha(z) expleft-fracalpha(z)r^22 + i(2p+l)arg(alpha(z))right alpha(z)(X + itextsgn(l)Y)^l L_p^l(alpha(z)^2 r^2)\n\nwhere X = xgamma, Y = ygamma, gamma = wsqrt2, r^2 = X^2 + Y^2, and alpha(z) = 1(1 + i2z(kw^2)).\n\nExamples\n\nrs = LinRange(-5, 5, 256)\nzs = LinRange(0, 1, 32)\n\n# just x and y\nψ₁ = lg(rs, rs, p=1, l=2)\nψ₂ = [lg(x, y, p=1, l=2) for x in rs, y in rs]\n\n# x, y and z\nψ₃ = lg(rs, rs, zs, p=1, l=2)\nψ₄ = [lg(x, y, z, p=1, l=2) for x in rs, y in rs, z ∈ zs]\n\nψ₃ ≈ ψ₄\n\n# output\n\ntrue\n\nSee also hg, diagonal_hg.\n\n\n\n\n\n","category":"function"},{"location":"beam_profiles/#StructuredLight.lg!","page":"Beam Profiles","title":"StructuredLight.lg!","text":"lg!(dest, x, y, z=zero(eltype(x)); p=0, l=0, w=one(eltype(x)), k=one(eltype(x)), N=normalization_lg(p, l, w))\n\nSame as lg, but writes the result to dest.\n\n\n\n\n\n","category":"function"},{"location":"beam_profiles/#StructuredLight.normalization_lg","page":"Beam Profiles","title":"StructuredLight.normalization_lg","text":"normalization_lg(p,l,w=1)\n\nCompute the normalization constant for the Laguerre-Gaussian modes.\n\nThis constant ensures that the integral of the absolute square of the mode is equal to 1.\n\nThe formula is given by:\n\nN_pl = frac1w sqrtfrac2ppi (p+l)\n\n\n\n\n\n","category":"function"},{"location":"beam_profiles/#Examples","page":"Beam Profiles","title":"Examples","text":"","category":"section"},{"location":"beam_profiles/","page":"Beam Profiles","title":"Beam Profiles","text":"Fundamental mode a distance z=.5 away from focus:","category":"page"},{"location":"beam_profiles/","page":"Beam Profiles","title":"Beam Profiles","text":"using StructuredLight, CairoMakie\r\nrs = LinRange(-3,3,256)\r\nψ₀ = lg(rs,rs,.5)\r\nvisualize(abs2.(ψ₀))","category":"page"},{"location":"beam_profiles/","page":"Beam Profiles","title":"Beam Profiles","text":"Analytical propagation of the fundamental mode:","category":"page"},{"location":"beam_profiles/","page":"Beam Profiles","title":"Beam Profiles","text":"using StructuredLight, CairoMakie\r\nrs = LinRange(-5,5,256) \r\nzs = LinRange(0,1,32)\r\nψs = lg(rs,rs,zs) \r\nsave_animation(abs2.(ψs),\"prop_fundamental.mp4\")\r\nnothing # hide","category":"page"},{"location":"beam_profiles/","page":"Beam Profiles","title":"Beam Profiles","text":"(Image: )","category":"page"},{"location":"beam_profiles/","page":"Beam Profiles","title":"Beam Profiles","text":"Analytical propagation of a more complicated Laguerre-Gauss:","category":"page"},{"location":"beam_profiles/","page":"Beam Profiles","title":"Beam Profiles","text":"using StructuredLight, CairoMakie\r\nrs = LinRange(-5,5,256) \r\nzs = LinRange(0,1,32)\r\nψs = lg(rs,rs,zs,p=1,l=-2)\r\nsave_animation(abs2.(ψs),\"prop_p=1,l=-2.mp4\")\r\nnothing # hide","category":"page"},{"location":"beam_profiles/","page":"Beam Profiles","title":"Beam Profiles","text":"(Image: )","category":"page"},{"location":"beam_profiles/#Hermite-Gauss","page":"Beam Profiles","title":"Hermite-Gauss","text":"","category":"section"},{"location":"beam_profiles/","page":"Beam Profiles","title":"Beam Profiles","text":"hg\r\nhg!\r\nnormalization_hg","category":"page"},{"location":"beam_profiles/#StructuredLight.hg","page":"Beam Profiles","title":"StructuredLight.hg","text":"hg(x, y, z=zero(eltype(x)); θ=zero(eltype(x)), m=0, n=0, w=one(eltype(x)), k=one(eltype(x)), N=normalization_hg(m, n, w), backend=CPU())\n\nCompute a Hermite-Gaussian mode.\n\nx, y and z can be numbers or collections, but x and y must be always of the same kind.\n\nOther Arguments:\n\nθ: rotation of the mode in the xy-plane, in radians. Default is 0.\nm: x index\nn: y index\nw: beam's waist\nk: wavenumber\nN: normalization constant. The default value computed by normalization_hg ensures that the integral of the absolute square of mode is equal to 1.\nbackend: backend to use for the computation, as defined in KernelAbstractions. Default is CPU(). You can use e.g., CUDABackend(), MetalBackend(), ROCBackend() or oneAPIBackend() for GPU computations.\n\nThe formula is given by:\n\npsi_mn(xyz) = N_mn alpha(z) expleftfracalpha(z)2(X^2 + Y^2) + i(m+n)arg(alpha(z))right H_m(alpha(z)X) H_n(alpha(z)Y)\n\nwhere X = (xcostheta + ysintheta)gamma, Y = (-xsintheta + ycostheta)gamma, gamma = wsqrt2, and alpha(z) = 1(1 + i2z(kw^2)).\n\nExamples\n\nrs = LinRange(-5, 5, 256)\nzs = LinRange(0, 1, 32)\n\n# just x and y\nψ₁ = hg(rs, rs, m=3, n=2)\nψ₂ = [hg(x, y, m=3, n=2) for x in rs, y in rs]\n\n# x, y and z\nψ₃ = hg(rs, rs, zs, m=3, n=2)\nψ₄ = [hg(x, y, z, m=3, n=2) for x in rs, y in rs, z ∈ zs]\n\nψ₁ ≈ ψ₂ && ψ₃ ≈ ψ₄\n\n# output\n\ntrue\n\nSee also diagonal_hg, lg.\n\n\n\n\n\n","category":"function"},{"location":"beam_profiles/#StructuredLight.hg!","page":"Beam Profiles","title":"StructuredLight.hg!","text":"hg!(dest, x, y, z=zero(eltype(x)); θ=zero(eltype(x)), m=0, n=0, w=one(eltype(x)), k=one(eltype(x)), N=normalization_hg(m, n, w))\n\nSame as hg, but writes the result to dest.\n\n\n\n\n\n","category":"function"},{"location":"beam_profiles/#StructuredLight.normalization_hg","page":"Beam Profiles","title":"StructuredLight.normalization_hg","text":"normalization_hg(m,n,w)\n\nCompute the normalization constant for the Hermite-Gaussian modes.\n\nThis constant ensures that the integral of the absolute square of the mode is equal to 1.\n\nThe formula is given by:\n\nN_mn = frac1w  left( pi 2^m+n-1 m n right)^-12\n\n\n\n\n\n","category":"function"},{"location":"beam_profiles/#Examples-2","page":"Beam Profiles","title":"Examples","text":"","category":"section"},{"location":"beam_profiles/","page":"Beam Profiles","title":"Beam Profiles","text":"Analytical propagation of a Hermite-Gauss with adjusted waist:","category":"page"},{"location":"beam_profiles/","page":"Beam Profiles","title":"Beam Profiles","text":"using StructuredLight, CairoMakie\r\nrs = LinRange(-6,6,256) \r\nzs = LinRange(0,.5,32)\r\nψs = hg(rs,rs,zs,m=1,n=2,w=.4)\r\nsave_animation(abs2.(ψs),\"prop_adjusted_waist.mp4\")\r\nnothing # hide","category":"page"},{"location":"beam_profiles/","page":"Beam Profiles","title":"Beam Profiles","text":"(Image: )","category":"page"},{"location":"beam_profiles/","page":"Beam Profiles","title":"Beam Profiles","text":"Superposition of Hermite-Gausss. Note that we can propagate backwards using negative values of z.","category":"page"},{"location":"beam_profiles/","page":"Beam Profiles","title":"Beam Profiles","text":"using StructuredLight, CairoMakie\r\nrs = LinRange(-4,4,256) \r\nzs = LinRange(-.5,.7,128)\r\nψ₀ = hg(rs,rs) + hg(rs,rs,n=2)/√2\r\nψs = free_propagation(ψ₀,rs,rs,zs)\r\nsave_animation(abs2.(ψs),\"prop_backwards.mp4\")\r\nnothing # hide","category":"page"},{"location":"beam_profiles/","page":"Beam Profiles","title":"Beam Profiles","text":"(Image: )","category":"page"},{"location":"beam_profiles/#Diagonal-Hermite-Gauss","page":"Beam Profiles","title":"Diagonal Hermite-Gauss","text":"","category":"section"},{"location":"beam_profiles/","page":"Beam Profiles","title":"Beam Profiles","text":"diagonal_hg\r\ndiagonal_hg!","category":"page"},{"location":"beam_profiles/#StructuredLight.diagonal_hg","page":"Beam Profiles","title":"StructuredLight.diagonal_hg","text":"diagonal_hg(x, y, z=zero(eltype(x)); m=0, n=0, w=one(eltype(x)), k=one(eltype(x)), N=normalization_hg(m, n, w), backend=CPU())\n\nCompute a diagonal Hermite-Gaussian mode. It is calculated by setting θ=π/4 in hg.\n\nSee also lg.\n\n\n\n\n\n","category":"function"},{"location":"beam_profiles/#StructuredLight.diagonal_hg!","page":"Beam Profiles","title":"StructuredLight.diagonal_hg!","text":"diagonal_hg!(dest, x, y, z=zero(eltype(x)); m=0, n=0, w=one(eltype(x)), k=one(eltype(x)), N=normalization_hg(m, n, w))\n\nSame as diagonal_hg, but writes the result to dest.\n\n\n\n\n\n","category":"function"},{"location":"beam_profiles/#Examples-3","page":"Beam Profiles","title":"Examples","text":"","category":"section"},{"location":"beam_profiles/","page":"Beam Profiles","title":"Beam Profiles","text":"Analytical propagation of a Hermite-Gauss with adjusted wavenumber:","category":"page"},{"location":"beam_profiles/","page":"Beam Profiles","title":"Beam Profiles","text":"using StructuredLight, CairoMakie\r\nrs = LinRange(-5,5,256) \r\nzs = LinRange(0,1,32)\r\nψs = diagonal_hg(rs,rs,zs,m=4,n=3,k=2)\r\nsave_animation(abs2.(ψs),\"prop_adjusted_k.mp4\")\r\nnothing # hide","category":"page"},{"location":"beam_profiles/","page":"Beam Profiles","title":"Beam Profiles","text":"(Image: )","category":"page"},{"location":"beam_profiles/#Aperture-Functions-and-Beam-Shaping","page":"Beam Profiles","title":"Aperture Functions & Beam Shaping","text":"","category":"section"},{"location":"beam_profiles/","page":"Beam Profiles","title":"Beam Profiles","text":"StructuredLight.jl provides several aperture functions for beam shaping and diffraction studies. These functions return boolean arrays indicating which points are within the aperture geometry.","category":"page"},{"location":"beam_profiles/","page":"Beam Profiles","title":"Beam Profiles","text":"rectangular_aperture\r\nsquare\r\nsingle_slit\r\ndouble_slit\r\npupil\r\ntriangle","category":"page"},{"location":"beam_profiles/#StructuredLight.rectangular_aperture","page":"Beam Profiles","title":"StructuredLight.rectangular_aperture","text":"rectangular_aperture(x, y, a, b)\n\nDetermine if points (x, y) are within a rectangular aperture centered at the origin. The rectangle has width a and height b.\n\nArguments\n\nx: x-coordinates of the points.\ny: y-coordinates of the points.\na: Width of the rectangle.\nb: Height of the rectangle.\n\nReturns\n\nA boolean array indicating whether each point is within the rectangular aperture.\n\n\n\n\n\n","category":"function"},{"location":"beam_profiles/#StructuredLight.square","page":"Beam Profiles","title":"StructuredLight.square","text":"square(x, y, l)\n\nDetermine if points (x, y) are within a square aperture centered at the origin. The square has side length l.\n\nArguments\n\nx: x-coordinates of the points.\ny: y-coordinates of the points.\nl: Side length of the square.\n\nReturns\n\nA boolean array indicating whether each point is within the square aperture.\n\n\n\n\n\n","category":"function"},{"location":"beam_profiles/#StructuredLight.single_slit","page":"Beam Profiles","title":"StructuredLight.single_slit","text":"single_slit(x, y, a)\n\nDetermine if points (x, y) are within a single slit aperture centered at the origin. The slit has width a and extends infinitely in the y-direction.\n\nArguments\n\nx: x-coordinates of the points.\ny: y-coordinates of the points.\na: Width of the slit.\n\nReturns\n\nA boolean array indicating whether each point is within the single slit aperture.\n\n\n\n\n\n","category":"function"},{"location":"beam_profiles/#StructuredLight.double_slit","page":"Beam Profiles","title":"StructuredLight.double_slit","text":"double_slit(x, y, a, d)\n\nDetermine if points (x, y) are within a double slit aperture centered at the origin. Each slit has width a and they are separated by distance d.\n\nArguments\n\nx: x-coordinates of the points.\ny: y-coordinates of the points.\na: Width of each slit.\nd: Distance between the centers of the slits.\n\nReturns\n\nA boolean array indicating whether each point is within the double slit aperture.\n\n\n\n\n\n","category":"function"},{"location":"beam_profiles/#StructuredLight.pupil","page":"Beam Profiles","title":"StructuredLight.pupil","text":"pupil(x, y, r)\n\nDetermine if points (x, y) are within a circular aperture centered at the origin.\n\nArguments\n\nx: x-coordinates of the points.\ny: y-coordinates of the points.\nr: Radius of the circle.\n\nReturns\n\nA boolean array indicating whether each point is within the circular aperture.\n\n\n\n\n\n","category":"function"},{"location":"beam_profiles/#StructuredLight.triangle","page":"Beam Profiles","title":"StructuredLight.triangle","text":"triangle(x, y, side_length)\n\nDetermine if points (x, y) are within an equilateral triangle aperture centered at the origin. The triangle has side length side_length.\n\nArguments\n\nx: x-coordinates of the points.\ny: y-coordinates of the points.\nside_length: Side length of the triangle.\n\nReturns\n\nA boolean array indicating whether each point is within the triangular aperture.\n\n\n\n\n\n","category":"function"},{"location":"beam_profiles/#Examples-4","page":"Beam Profiles","title":"Examples","text":"","category":"section"},{"location":"beam_profiles/","page":"Beam Profiles","title":"Beam Profiles","text":"Basic rectangular aperture:","category":"page"},{"location":"beam_profiles/","page":"Beam Profiles","title":"Beam Profiles","text":"using StructuredLight, CairoMakie\r\nxs = LinRange(-2, 2, 256)\r\nys = LinRange(-2, 2, 256)\r\naperture = rectangular_aperture(xs, ys, 1.5, 1.0)\r\nvisualize(aperture)","category":"page"},{"location":"beam_profiles/","page":"Beam Profiles","title":"Beam Profiles","text":"Single slit diffraction setup:","category":"page"},{"location":"beam_profiles/","page":"Beam Profiles","title":"Beam Profiles","text":"using StructuredLight, CairoMakie\r\nxs = LinRange(-3, 3, 256)\r\nys = LinRange(-3, 3, 256)\r\nslit = single_slit(xs, ys, 0.5)\r\nvisualize(slit)","category":"page"},{"location":"beam_profiles/","page":"Beam Profiles","title":"Beam Profiles","text":"Double slit interference:","category":"page"},{"location":"beam_profiles/","page":"Beam Profiles","title":"Beam Profiles","text":"using StructuredLight, CairoMakie\r\nxs = LinRange(-4, 4, 256)\r\nys = LinRange(-4, 4, 256)\r\ndouble_slits = double_slit(xs, ys, 0.3, 2.0)\r\nvisualize(double_slits)","category":"page"},{"location":"beam_profiles/","page":"Beam Profiles","title":"Beam Profiles","text":"Circular pupil (common in optical systems):","category":"page"},{"location":"beam_profiles/","page":"Beam Profiles","title":"Beam Profiles","text":"using StructuredLight, CairoMakie\r\nxs = LinRange(-2, 2, 256)\r\nys = LinRange(-2, 2, 256)\r\ncircular_aperture = pupil(xs, ys, 1.0)\r\nvisualize(circular_aperture)","category":"page"},{"location":"beam_profiles/","page":"Beam Profiles","title":"Beam Profiles","text":"Beam shaping with apertures - applying aperture to Gaussian beam:","category":"page"},{"location":"beam_profiles/","page":"Beam Profiles","title":"Beam Profiles","text":"using StructuredLight, CairoMakie\r\nxs = LinRange(-3, 3, 256)\r\nys = LinRange(-3, 3, 256)\r\ngaussian_beam = hg(xs, ys)\r\nsquare_aperture = square(xs, ys, 2.0)\r\nshaped_beam = gaussian_beam .* square_aperture\r\nvisualize(abs2.(shaped_beam))","category":"page"},{"location":"beam_profiles/#Advanced-Beam-Manipulation","page":"Beam Profiles","title":"Advanced Beam Manipulation","text":"","category":"section"},{"location":"beam_profiles/","page":"Beam Profiles","title":"Beam Profiles","text":"For creating complex beam patterns through superposition of multiple functions:","category":"page"},{"location":"beam_profiles/","page":"Beam Profiles","title":"Beam Profiles","text":"linear_combination\r\ngrid_linear_combination\r\ngrid_linear_combination!","category":"page"},{"location":"beam_profiles/#StructuredLight.linear_combination","page":"Beam Profiles","title":"StructuredLight.linear_combination","text":"linear_combination(funcs, coeffs, arg)\n\nCompute a linear combination of functions funcs with coefficients coeffs evaluated at arg.\n\nf(x) = x^2\ng(x) = x\n\nfuncs = (f, g)\ncoeffs = (1, 2)\n\nlinear_combination(funcs, coeffs, 2) == 1 * f(2) + 2 * g(2)\n\n# output\n\ntrue\n\n\n\n\n\n","category":"function"},{"location":"beam_profiles/#StructuredLight.grid_linear_combination","page":"Beam Profiles","title":"StructuredLight.grid_linear_combination","text":"grid_linear_combination(funcs, coeffs, grid; backend=CPU())\n\nCompute a linear combination of functions funcs with coefficients coeffs evaluated in the grid.\n\nEach function in funcs should accept a Tuple of arguments corresponding to the point on the grid where it should be evaluated. \n\ngrid should be specified as a Tuple of arguments: the number of arguments determines the number of dimensions in the grid, and each argument should be a collections of coordinates along one dimension.\n\nThe result is returned as an array of type eltype in the specified backend.\n\nrs = LinRange(-3, 3, 100)\ngrid = (rs, rs)\nf1(args) = hg(args..., m=1)\nf2(args) = hg(args..., n=1)\n\nfuncs = (f1, f2)\ncoeffs = (1 / √2, im / √2)\n\ngrid_linear_combination(funcs, coeffs, grid) ≈ lg(rs, rs, l=1)\n\n# output\n\ntrue\n\n\n\n\n\n","category":"function"},{"location":"beam_profiles/#StructuredLight.grid_linear_combination!","page":"Beam Profiles","title":"StructuredLight.grid_linear_combination!","text":"grid_linear_combination!(dest, funcs, coeffs, grid)\n\nSame as grid_linear_combination, but writes the result into dest instead of returning it.\n\n\n\n\n\n","category":"function"},{"location":"beam_profiles/#Examples-5","page":"Beam Profiles","title":"Examples","text":"","category":"section"},{"location":"beam_profiles/","page":"Beam Profiles","title":"Beam Profiles","text":"Creating a superposition of Hermite-Gaussian modes:","category":"page"},{"location":"beam_profiles/","page":"Beam Profiles","title":"Beam Profiles","text":"using StructuredLight, CairoMakie\r\nrs = LinRange(-3, 3, 100)\r\ngrid = (rs, rs)\r\n\r\n# Define component functions\r\nf1(args) = hg(args..., m=1)\r\nf2(args) = hg(args..., n=1)\r\n\r\nfuncs = (f1, f2)\r\ncoeffs = (1/√2, im/√2)\r\n\r\n# This creates a Laguerre-Gaussian mode through HG superposition\r\nsuperposition = grid_linear_combination(funcs, coeffs, grid)\r\nvisualize(abs2.(superposition), scaling=4)","category":"page"},{"location":"beam_profiles/","page":"Beam Profiles","title":"Beam Profiles","text":"Creating custom beam patterns with multiple components:","category":"page"},{"location":"beam_profiles/","page":"Beam Profiles","title":"Beam Profiles","text":"using StructuredLight, CairoMakie\r\nrs = LinRange(-4, 4, 128)\r\ngrid = (rs, rs)\r\n\r\n# Define multiple beam components\r\nf1(args) = lg(args..., p=0, l=1)  # Vortex beam\r\nf2(args) = hg(args..., m=2, n=0)  # Hermite-Gaussian\r\nf3(args) = hg(args..., m=0, n=2)  # Another HG mode\r\n\r\nfuncs = (f1, f2, f3)\r\ncoeffs = (0.6, 0.3, 0.3)\r\n\r\ncomplex_beam = grid_linear_combination(funcs, coeffs, grid)\r\nvisualize(abs2.(complex_beam), scaling=4)","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This package is a comprehensive toolkit for working with spatially structured light beams in Julia. It offers a range of functionalities for simulating, propagating, and visualizing structured light beams, such as Laguerre-Gauss and Hermite-Gauss modes. It also implements the computation of holograms used for producing such beams in Spatial Light Modulators (SLMs). The package supports both CPU and GPU computations, allowing for efficient simulations.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Here is a brief overview of the main features:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Beam Profiles: Calculate a large variety of beam profiles, such as Hermite-Gauss and Laguerre-Gauss modes.\nVisualization: Tools for visualizing the beam profiles and their propagation.\nPropagation: Simulate the propagation of beams in free space and in Kerr media.\nHolograms: Compute holograms for generating structured light beams on SLMs.\nPhase Modulation: Tools for applying phase modulation to structured light beams, including aberration correction, lens simulation, and custom phase masks using Zernike polynomials.\nGPU Support: Efficient computation on GPUs.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Check Quick Start for a quick introduction to the package.","category":"page"}]
}
