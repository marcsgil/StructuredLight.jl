var documenterSearchIndex = {"docs":
[{"location":"propagation/#Propagation","page":"Propagation","title":"Propagation","text":"","category":"section"},{"location":"propagation/","page":"Propagation","title":"Propagation","text":"The heavy lifting in this package is done by the propagation methods. The basic principle is that you give an initial profile and the grid over which it was calculated, and we give back to you the propagated beam. For now, we have included propagation in free space (free_propagation) and in Kerr Media (kerr_propagation). The implementation of propagation in media with quadratic nonlinearity is on the horizon.","category":"page"},{"location":"propagation/#free_propagation","page":"Propagation","title":"free_propagation","text":"","category":"section"},{"location":"propagation/","page":"Propagation","title":"Propagation","text":"free_propagation","category":"page"},{"location":"propagation/#StructuredLight.free_propagation","page":"Propagation","title":"StructuredLight.free_propagation","text":"free_propagation(ψ, x, y, z [, scaling]; k=1)\n\nPropagate an inital profile ψ.\n\nThe propagation is the solution of ∇² ψ + 2ik ∂_z ψ = 0 at distance z under the initial condition ψ.\n\nx and y are the grids over which ψ is calculated.\n\nIf z is an AbstractArray, the output is a 3D array representing the solution at every element of z.\n\nThe output at a distance z[n] is calculated on a scalled grid defined by scaling[n] * x and scaling[n] * y.\n\nk is the wavenumber.\n\nExample\n\nx = LinRange(-10, 10, 256)\ny = LinRange(-10, 10, 512)\nz = LinRange(0.1, 1, 10)\n\nψ = hg(x, y; m=3, n=2)\nψ′ = hg(2x, 2y; m=3, n=2)\n\n(\n    free_propagation(ψ, x, y, z) ≈ stack(free_propagation(ψ, x, y, z) for z ∈ z)\n    &&\n    free_propagation(ψ, x, y, z, fill(2, length(z))) ≈ stack(free_propagation(ψ, x, y, z, 2) for z ∈ z)\n    &&\n    free_propagation(ψ, x, y, 0.5, 2) ≈ free_propagation(ψ′, 2x, 2y, 0.5)\n)\n\n# output\ntrue\n\n\n\n\n\n","category":"function"},{"location":"propagation/#Examples:","page":"Propagation","title":"Examples:","text":"","category":"section"},{"location":"propagation/","page":"Propagation","title":"Propagation","text":"#The simplest usage would be the following:\r\nusing StructuredLight, CairoMakie\r\n\r\nrs = LinRange(-6,6,256)\r\n\r\n#Here we define an initial profile that isn't invariant upon propagation.\r\nψ₀ = lg(rs,rs) / 2 + lg(rs,rs,p=1)\r\n\r\nψ = free_propagation(ψ₀,rs,rs,1) #Then, we propagate it by a distance z=1.\r\n\r\n#Here are the initial profiles the propagated beam, side by side.\r\nvisualize([ψ₀,ψ] |> stack .|> abs2)","category":"page"},{"location":"propagation/","page":"Propagation","title":"Propagation","text":"#We can also provide a collection of z values to produce an animation:\r\nusing StructuredLight, CairoMakie\r\n\r\nrs = LinRange(-12,12,256)\r\nzs = LinRange(0,1,64)\r\n\r\n#This is a laguerre-gaussian modulated by a sine function.\r\nψ₀ = lg(rs,rs,l=2,p=1) .* map(r->sin(6*r[2]),Iterators.product(rs,rs))\r\n\r\n#Now the propagation is performed for each z ∈ zs. The output is a 3D array.\r\nψs = free_propagation(ψ₀,rs,rs,zs)\r\n\r\nsave_animation(abs2.(ψs), \"lg_times_sin.mp4\")","category":"page"},{"location":"propagation/","page":"Propagation","title":"Propagation","text":"(Image: )","category":"page"},{"location":"propagation/","page":"Propagation","title":"Propagation","text":"using StructuredLight, CairoMakie\r\n\r\nrs = LinRange(-4,4,256)\r\nzs = LinRange(.01,1,32)\r\n\r\n#This is a gaussian mode\r\nψ₀ = lg(rs,rs)\r\nscalings = @. √(1+zs^2) #Here, we introduce the scalings given by w(z)/w0\r\n\r\n#Now we propagate, including the scalings\r\nψs = free_propagation(ψ₀,rs,rs,zs,scalings)\r\n\r\n#Note that the scalings compensate the diffraction of the beam.\r\n#Therefore, the animation seems still.\r\nsave_animation(abs2.(ψs), \"standing_still.mp4\")","category":"page"},{"location":"propagation/","page":"Propagation","title":"Propagation","text":"(Image: )","category":"page"},{"location":"propagation/#References","page":"Propagation","title":"References","text":"","category":"section"},{"location":"propagation/","page":"Propagation","title":"Propagation","text":"The book \"Schmidt, J. D. (2010). Numerical Simulation of Optical Wave Propagation with Examples in MATLAB. United States: SPIE.\" is a great resource to learn about numerical propagation of paraxial light beams","category":"page"},{"location":"propagation/#kerr_propagation","page":"Propagation","title":"kerr_propagation","text":"","category":"section"},{"location":"propagation/","page":"Propagation","title":"Propagation","text":"kerr_propagation","category":"page"},{"location":"propagation/#StructuredLight.kerr_propagation","page":"Propagation","title":"StructuredLight.kerr_propagation","text":"kerr_propagation(ψ₀,xs,ys,zs,total_steps;k=1,g=1)\n\nSolve ∇² ψ + 2ik ∂_z ψ = - g |ψ|² ψ under the initial condition ψ₀.\n\nxs and ys are the grids over which ψ₀ is calculated.\n\nThe outputs are saved at every zs, which is a number or a collection of numbers.\n\ntotal_steps is the number of steps over which we discretize the propagation. The larger the total_steps, the better the precision and the slower is the calculation.\n\n\n\n\n\n","category":"function"},{"location":"propagation/#Example","page":"Propagation","title":"Example","text":"","category":"section"},{"location":"propagation/","page":"Propagation","title":"Propagation","text":"using StructuredLight, CairoMakie\r\n\r\nrs = LinRange(-2.5,2.5,256) #The transverse grid\r\nzs = LinRange(0,.12,32) #The z grid\r\n\r\nψ₀ = lg(rs,rs) #Calculates the fundamental Laguerre-Gaussian mode\r\n\r\n#We perform the propagation with a strong nonlinearity\r\nψ = kerr_propagation(ψ₀,rs,rs,zs,512,g=200)\r\n\r\nsave_animation(abs2.(ψ), \"kerr.mp4\") #The beam colapses due to the self focusing effect","category":"page"},{"location":"propagation/","page":"Propagation","title":"Propagation","text":"(Image: )","category":"page"},{"location":"propagation/#References-2","page":"Propagation","title":"References","text":"","category":"section"},{"location":"propagation/","page":"Propagation","title":"Propagation","text":"The package NonlinearSchrodinger.jl has more available solvers for this equation, but, as far as I can see, it only works with one spatial dimensional. Its author has also written a paper that explains the theory that goes behind the numerical solution.","category":"page"},{"location":"propagation/#CUDA-support","page":"Propagation","title":"CUDA support","text":"","category":"section"},{"location":"propagation/","page":"Propagation","title":"Propagation","text":"Both free_propagation and kerr_propagation can be run on Nvidia GPUs, which will greatly improve the performance of these functions. If you have one, you simply need to convert your initial profile to a CuArray and pass this converted array to the propagation methods (check the CUDA.jl documentation for more details). Then, multiple dispatch will do its magic!","category":"page"},{"location":"propagation/","page":"Propagation","title":"Propagation","text":"Here is an example:","category":"page"},{"location":"propagation/","page":"Propagation","title":"Propagation","text":"using StructuredLight, CairoMakie\r\nusing CUDA #It is necessary to load the CUDA package\r\n\r\nψ₀ = lg(rs,rs) |> cu #Transfers array to GPU\r\n\r\nψ = free_propagation(ψ₀,rs,rs,zs) #This is running on the GPU!","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Mode-Converter","page":"Examples","title":"Mode Converter","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this example, we reproduce the results of Beijersbergen, Marco W., et al. \"Astigmatic laser mode converters and transfer of orbital angular momentum.\" Optics Communications 96.1-3 (1993): 123-132., where it is shown that a tilted lens can \"transform\" a Laguerre-Gauss mode in a diagonal Hermite-Gauss mode.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using StructuredLight, CairoMakie\r\nk = 1\r\nf = √2\r\nd = f / √2\r\nw = √((2 + √2) * f / k)\r\nrs = LinRange(-4w, 4w, 512)\r\nzs = LinRange(0, 2d, 64)\r\n##\r\nψ₀ = lg(rs, rs, -d; γ = w / √2, k, l=1, p=0)\r\nlens!(ψ₀, rs, rs, Inf, f; k) #Applies a cylindrical lens\r\nψ₁ = free_propagation(ψ₀, rs, rs, 2d; k)\r\nψs = free_propagation(ψ₀, rs, rs, zs; k)\r\n\r\nvisualize(abs2.([ψ₀, ψ₁] |> stack))","category":"page"},{"location":"examples/#Astigmatic-Conversion","page":"Examples","title":"Astigmatic Conversion","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this example, we reproduce the results of Pravin Vaity et al., \"Measuring topological charge of optical vortices using a tilted convex lens,\" Phys. Lett. A, vol. 377, no. 15, pp. 1154-1156, 2013. DOI: 10.1016/j.physleta.2013.02.030, where it is shown that a tilted lens can \"transform\" a Laguerre-Gauss mode in a diagonal Hermite-Gauss mode.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using StructuredLight, CairoMakie\r\n\r\n#All quantities have unit of (inverse) meter\r\n\r\nw = 0.16e-3 #Waist\r\nγ = w / sqrt(2)\r\nλ = 632.8e-9 #Wavelength\r\nk = 2π/λ #Wavenumber\r\nf = 50e-2 #Focal length of the lens\r\n\r\nz₀ = 3.1 #Distance away from the focus where the beam encounters the lens\r\n\r\nz_cr = z₀/(z₀/f-1) #Conversion distance\r\n\r\nξ = deg2rad(6) #Tilting angle\r\n\r\n# Now, we set up our grid and the initial profile by including the action of a tilted lens:\r\nrs = LinRange(-70w,70w,1024)\r\nψ₀ = lg(rs,rs,z₀,l=3; γ, k)\r\ntilted_lens!(ψ₀,rs,rs,f,ξ;k) #Applies the lens\r\n\r\n# Finally, we propagate. \r\n# Note that we introduce scalings, because, otherwise, the beam would be to small.\r\nzs = z_cr .* LinRange(.97,1.03,64)\r\nscalings = 0.015 .* vcat(LinRange(2.4,1,32),LinRange(1,2.4,32))\r\nψ = free_propagation(ψ₀,rs,rs,zs,k=k,scalings)\r\nanim = save_animation(abs2.(ψ),\"tilted_lens.mp4\",framerate=12)\r\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"By changing the initial angular momentum, one obtains different HG modes.","category":"page"},{"location":"examples/#Diffraction-Rings-in-Kerr-Media","page":"Examples","title":"Diffraction Rings in Kerr Media","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Here, we reproduce the results of E. V. Garcia Ramirez, M. L. Arroyo Carrasco, M. M. Mendez Otero, S. Chavez Cerda, and M. D. Iturbe Castillo, \"Far field intensity distributions due to spatial self phase modulation of a Gaussian beam by a thin nonlocal nonlinear media,\" Opt. Express 18, 22067-22079 (2010), where it is studied the appearance of rings in the far field profile of a Gaussian beam after it crosses a nonlinear medium.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"#First we import the package.\r\nusing StructuredLight, CairoMakie\r\n\r\n#Define a function that calculates the nonlinear phase term.\r\nfunction non_linear_phase(ψ,m,n)\r\n    M = maximum(abs2,ψ)\r\n    [ cis( π * n * (abs2(ψ[j,k])/M)^(m/2) ) for j ∈ axes(ψ,1), k ∈ axes(ψ,2) ]\r\nend\r\n\r\n#Define a function that calculates the three images.\r\nfunction get_images(rs,ms,n,z₀,z,scalling)\r\n    ψ = Array{ComplexF64}(undef,length(rs),length(rs),length(ms))\r\n\r\n    ψ₀ = lg(rs,rs,z₀)\r\n\r\n    for (i,m) in enumerate(ms)\r\n        ψ₁ = ψ₀ .* non_linear_phase(ψ₀,m,n)\r\n        ψ[:,:,i] = free_propagation(ψ₁,rs,rs,z,scalling)\r\n    end\r\n\r\n    ψ\r\nend\r\n\r\n#The values of `m` that are used throughout the article:\r\nms = (1,2,4)\r\n\r\n#The Rayleigh range:\r\nzᵣ = 1/2;\r\n\r\n# This would be the figure 1:\r\nrs = LinRange(-10,10,512)\r\nvisualize(abs2.(get_images(rs,ms,2,-4zᵣ,15,10)))","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The other figures are just a variation of this one, by changing the distance from the waist and n.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Alternatively, we can solve the complete nonlinear Schrödinger equation to get the initial profile:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using StructuredLight, CairoMakie\r\nrs = LinRange(-10,10,512)\r\nzᵣ = 1/2\r\nψ₀ = lg(rs,rs,-4zᵣ)\r\nM = maximum(abs2,ψ₀)\r\n\r\nn = 2\r\nψ₁ = kerr_propagation(ψ₀,rs,rs,.01*zᵣ,512,g=400*n*π/M)\r\n\r\n#The output of this free propagation should then be equal to the previous case with `m=2`:\r\nψ = free_propagation(ψ₁,rs,rs,10,7)\r\nvisualize(abs2.(ψ))","category":"page"},{"location":"miscellany/#Miscellany","page":"Miscellany","title":"Miscellany","text":"","category":"section"},{"location":"miscellany/","page":"Miscellany","title":"Miscellany","text":"Here we show a few small functionalities that didn't fit anywhere else.","category":"page"},{"location":"miscellany/","page":"Miscellany","title":"Miscellany","text":"overlap","category":"page"},{"location":"miscellany/#StructuredLight.overlap","page":"Miscellany","title":"StructuredLight.overlap","text":"overlap(ψ₁,ψ₂,xs,ys)\n\nCalculate ∫ ψ₁ conj(ψ₂) dx dy.\n\nxs and ys are the grids over which ψ₁ and ψ₂ are calculated.\n\n\n\n\n\noverlap(ψ₁::AbstractArray{T1,3},ψ₂::AbstractArray{T2,3},xs,ys) where {T1,T2}\n\nCalculate ∫ ψ₁[:,:,j] conj(ψ₂[:,:,j]) dx dy, where j runs over all indices of the third dimension. \n\nThe output is a vector.\n\nxs and ys are the grids over which ψ₁ and ψ₂ are calculated.\n\n\n\n\n\n","category":"function"},{"location":"miscellany/","page":"Miscellany","title":"Miscellany","text":"using StructuredLight, CairoMakie\r\n\r\nrs = LinRange(-5,5,256) \r\nψ₁ = hg(rs,rs)\r\nψ₂ = hg(rs,rs,m=1)\r\n\r\noverlap(ψ₁,ψ₁,rs,rs) #The modes are normalized\r\noverlap(ψ₁,ψ₂,rs,rs) #Modes with different indices are orthogonal\r\n\r\nzs = LinRange(0,.5,8)\r\nψ₁s = free_propagation(ψ₁,rs,rs,zs)\r\nψ₂s = free_propagation(ψ₂,rs,rs,zs)\r\n\r\n# Free propagation is an unitary transformation\r\n# Therefore, it preserves the overlap\r\noverlap(ψ₁s,ψ₁s,rs,rs), overlap(ψ₁s,ψ₂s,rs,rs) ","category":"page"},{"location":"visualization/#Visualization","page":"Visualization","title":"Visualization","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"This package offer tools that help the visualization of the generated beams.","category":"page"},{"location":"visualization/#visualize","page":"Visualization","title":"visualize","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"The simplest of such tools is the visualize function, which displays the beam as a static image. It accepts two, three and four dimensional arrays.","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"visualize","category":"page"},{"location":"visualization/#StructuredLight.visualize","page":"Visualization","title":"StructuredLight.visualize","text":"visualize(img;\ncolormap=:jet, colorrange=Makie.automatic,\nshare_colorrange=false, max_size=1080)\n\nVizualize the image(s) img.\n\nimg can be a 2D, 3D or 4D array.\n\nWhen using the 3D Array signature, the third dimension is interpreted as defining different images, which are displayed in a row.\n\nWhen using the 4D Array signature, the third and fourth dimensions are interpreted as defining different images, which are displayed in a matrix.\n\nkeyword arguments\n\ncolormap defines the colormap of the image(s).\n\nmax_size defines the maximum side length of the image, which is passed to Makie.Figure.\n\nshare_colorrange defines if the color range should be shared between all images. Has no effect for the 2D Array signature.\n\ncolorrange defines the color range of the image(s).\n\n\n\n\n\n","category":"function"},{"location":"visualization/#Example:","page":"Visualization","title":"Example:","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"using StructuredLight, CairoMakie\n\nrs = LinRange(-4,4,256) \n\nψ₁ = stack( [diagonal_hg(rs,rs,m=3), diagonal_hg(rs,rs,n=3)] )\n\nψ₂ = stack( [hg(rs,rs,m=3), hg(rs,rs,n=3)] )\n\nvisualize(abs2.(ψ₁)) #Displays ψ₁ \n\nvisualize(abs2.(ψ₂)) #Displays ψ₂\n\nψ₃ = stack([ψ₁,ψ₂])\n\nvisualize(abs2.(ψ₃)) #Displays ψ₁ and ψ₂ in a row.","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"With three-dimensional arrays, which are interpreted as a sequence of 2D images, we can also form different kinds of animations. ","category":"page"},{"location":"visualization/#save_animation","page":"Visualization","title":"save_animation","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"save_animation will save the animation on the given path.","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"save_animation","category":"page"},{"location":"visualization/#StructuredLight.save_animation","page":"Visualization","title":"StructuredLight.save_animation","text":"save_animation(img::AbstractArray{T,3}, path;\ncolormap=:jet, share_colorrange=false, max_size=1080, framerate=16) where {T<:Real}\n\nSave an animation of img at path with a framerate.\n\nThe colors are given by colormap.\n\nmax_size defines the maximum side length of the image, which is passed to Makie.Figure.\n\nshare_colorrange defines if the color range should be shared between all images.\n\n\n\n\n\n","category":"function"},{"location":"visualization/#Example:-2","page":"Visualization","title":"Example:","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"using StructuredLight, CairoMakie\n\nrs = LinRange(-6,6,256) \nzs = LinRange(0,1,32)\n\nψ₀ = hg(rs,rs) + hg(rs,rs,n=2)/√2\n\nψs = free_propagation(ψ₀,rs,rs,zs)\n\nsave_animation(abs2.(ψs),\"animation.mp4\",framerate=12)\n\nnothing # hide","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"(Image: )","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This package provides tools to simulate the propagation of paraxial light beams. This includes the calculation of Laguerre-Gauss and Hermite-Gauss beam profiles, the action of Lenses, the propagation in free space (free_propagation) as well as in Kerr media (kerr_propagation). Both the propagation methods can be run on Nvidia GPUs (check CUDA support for details). We also provide methods that help the Visualization of such beams.","category":"page"},{"location":"#Minimal-Example","page":"Introduction","title":"Minimal Example","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The following code is a minimal working example for this package:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using StructuredLight\r\n\r\nrs = LinRange(-5,5,256) #Define a linear grid of points\r\n\r\nψ₀ = lg(rs,rs) #Calculates the fundamental Laguerre-Gaussian mode\r\n\r\nψ = free_propagation(ψ₀,rs,rs,1) #Propagates the mode through a distance of z=1\r\n\r\nusing CairoMakie # for the visualization\r\n\r\nfig = Figure(size = (1600,800), figure_padding=0)\r\nax1 = Axis(fig[1,1])\r\nax2 = Axis(fig[1,2])\r\nhidedecorations!(ax1)\r\nhidedecorations!(ax2)\r\n\r\nheatmap!(ax1, abs2.(ψ₀), colormap = :jet) #visualizes the initial mode\r\nheatmap!(ax2, abs2.(ψ), colormap = :jet) #visualizes the propagated mode\r\n\r\nfig","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"This illustrates the basic idea of the package: first, you construct a matrix representing the mode you want to propagate, and then one calls a propagation function, in this case free_propagation. Then, we visualize the propagated beam.","category":"page"},{"location":"#Contents","page":"Introduction","title":"Contents","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Pages = [\r\n        \"index.md\",\r\n        \"initial_profiles.md\",\r\n        \"visualization.md\",\r\n        \"propagation.md\",\r\n        \"miscellany.md\",\r\n        \"examples.md\"\r\n    ]","category":"page"},{"location":"initial_profiles/#Initial-Profiles","page":"Initial Profiles","title":"Initial Profiles","text":"","category":"section"},{"location":"initial_profiles/","page":"Initial Profiles","title":"Initial Profiles","text":"This package implements the Laguerre-Gauss modes (lg), the Hermite-Gauss modes (hg) and its diagonal version (diagonal_hg).","category":"page"},{"location":"initial_profiles/","page":"Initial Profiles","title":"Initial Profiles","text":"In all cases, one must specify the points or the grids over which the mode is calculated. The other beam parameters are specified through keyword arguments.","category":"page"},{"location":"initial_profiles/#Laguerre-Gauss","page":"Initial Profiles","title":"Laguerre-Gauss","text":"","category":"section"},{"location":"initial_profiles/","page":"Initial Profiles","title":"Initial Profiles","text":"lg","category":"page"},{"location":"initial_profiles/#StructuredLight.lg","page":"Initial Profiles","title":"StructuredLight.lg","text":"lg(x, y, z=zero(eltype(x)); p=0, l=0, w=one(eltype(x)), k=one(eltype(x)))\n\nCompute a diagonal Hermite-Gaussian mode.\n\nx, y and z can be numbers or vectors, but x and y must be always of the same kind.\n\nOther Arguments:\n\np: radial index\nl: topological charge\nw: beam's waist\nk: wavenumber\n\nExamples\n\nrs = LinRange(-5, 5, 256)\nzs = LinRange(0, 1, 32)\n\n# just x and y\nψ₁ = lg(rs, rs, p=1, l=2)\nψ₂ = [lg(x, y, p=1, l=2) for x in rs, y in rs]\n\n# x, y and z\nψ₃ = lg(rs, rs, zs, p=1, l=2)\nψ₄ = [lg(x, y, z, p=1, l=2) for x in rs, y in rs, z ∈ zs]\n\nψ₃ ≈ ψ₄\n\n# output\n\ntrue\n\nSee also hg, diagonal_hg.\n\n\n\n\n\n","category":"function"},{"location":"initial_profiles/#Examples","page":"Initial Profiles","title":"Examples","text":"","category":"section"},{"location":"initial_profiles/","page":"Initial Profiles","title":"Initial Profiles","text":"Fundamental mode a distance z=.5 away from focus:","category":"page"},{"location":"initial_profiles/","page":"Initial Profiles","title":"Initial Profiles","text":"using StructuredLight, CairoMakie\r\nrs = LinRange(-3,3,256)\r\nψ₀ = lg(rs,rs,.5)\r\nvisualize(abs2.(ψ₀))","category":"page"},{"location":"initial_profiles/","page":"Initial Profiles","title":"Initial Profiles","text":"Analytical propagation of the fundamental mode:","category":"page"},{"location":"initial_profiles/","page":"Initial Profiles","title":"Initial Profiles","text":"using StructuredLight, CairoMakie\r\nrs = LinRange(-5,5,256) \r\nzs = LinRange(0,1,32)\r\nψs = lg(rs,rs,zs) \r\nsave_animation(abs2.(ψs),\"prop_fundamental.mp4\")\r\nreturn nothing # hide","category":"page"},{"location":"initial_profiles/","page":"Initial Profiles","title":"Initial Profiles","text":"(Image: )","category":"page"},{"location":"initial_profiles/","page":"Initial Profiles","title":"Initial Profiles","text":"Analytical propagation of a more complicated Laguerre-Gauss:","category":"page"},{"location":"initial_profiles/","page":"Initial Profiles","title":"Initial Profiles","text":"using StructuredLight, CairoMakie\r\nrs = LinRange(-5,5,256) \r\nzs = LinRange(0,1,32)\r\nψs = lg(rs,rs,zs,p=1,l=-2)\r\nsave_animation(abs2.(ψs),\"prop_p=1,l=-2.mp4\")\r\nreturn nothing # hide","category":"page"},{"location":"initial_profiles/","page":"Initial Profiles","title":"Initial Profiles","text":"(Image: )","category":"page"},{"location":"initial_profiles/#Hermite-Gauss","page":"Initial Profiles","title":"Hermite-Gauss","text":"","category":"section"},{"location":"initial_profiles/","page":"Initial Profiles","title":"Initial Profiles","text":"hg","category":"page"},{"location":"initial_profiles/#StructuredLight.hg","page":"Initial Profiles","title":"StructuredLight.hg","text":"hg(x, y, z=zero(eltype(x)); θ=zero(eltype(x)), m=0, n=0, w=one(eltype(x)), k=one(eltype(x)))\n\nCompute a Hermite-Gaussian mode.\n\nx, y and z can be numbers or vectors, but x and y must be always of the same kind.\n\nOther Arguments:\n\nm: x index\nn: y index\nw: beam's waist\nk: wavenumber\n\nExamples\n\nrs = LinRange(-5, 5, 256)\nzs = LinRange(0, 1, 32)\n\n# just x and y\nψ₁ = hg(rs, rs, m=3, n=2)\nψ₂ = [hg(x, y, m=3, n=2) for x in rs, y in rs]\n\n# x, y and z\nψ₃ = hg(rs, rs, zs, m=3, n=2)\nψ₄ = [hg(x, y, z, m=3, n=2) for x in rs, y in rs, z ∈ zs]\n\nψ₁ ≈ ψ₂ && ψ₃ ≈ ψ₄\n\n# output\n\ntrue\n\nSee also diagonal_hg, lg.\n\n\n\n\n\n","category":"function"},{"location":"initial_profiles/#Examples-2","page":"Initial Profiles","title":"Examples","text":"","category":"section"},{"location":"initial_profiles/","page":"Initial Profiles","title":"Initial Profiles","text":"Analytical propagation of a Hermite-Gauss with adjusted waist:","category":"page"},{"location":"initial_profiles/","page":"Initial Profiles","title":"Initial Profiles","text":"using StructuredLight, CairoMakie\r\nrs = LinRange(-6,6,256) \r\nzs = LinRange(0,.5,32)\r\nψs = hg(rs,rs,zs,m=1,n=2,γ=.4)\r\nsave_animation(abs2.(ψs),\"prop_adjusted_waist.mp4\")","category":"page"},{"location":"initial_profiles/","page":"Initial Profiles","title":"Initial Profiles","text":"(Image: )","category":"page"},{"location":"initial_profiles/","page":"Initial Profiles","title":"Initial Profiles","text":"Superposition of Hermite-Gausss. Note that we can propagate backwards using negative values of z.","category":"page"},{"location":"initial_profiles/","page":"Initial Profiles","title":"Initial Profiles","text":"using StructuredLight, CairoMakie\r\nrs = LinRange(-4,4,256) \r\nzs = LinRange(-.5,.7,128)\r\nψ₀ = hg(rs,rs) + hg(rs,rs,n=2)/√2\r\nψs = free_propagation(ψ₀,rs,rs,zs)\r\nsave_animation(abs2.(ψs),\"prop_backwards.mp4\")","category":"page"},{"location":"initial_profiles/","page":"Initial Profiles","title":"Initial Profiles","text":"(Image: )","category":"page"},{"location":"initial_profiles/#Diagonal-Hermite-Gauss","page":"Initial Profiles","title":"Diagonal Hermite-Gauss","text":"","category":"section"},{"location":"initial_profiles/","page":"Initial Profiles","title":"Initial Profiles","text":"diagonal_hg","category":"page"},{"location":"initial_profiles/#StructuredLight.diagonal_hg","page":"Initial Profiles","title":"StructuredLight.diagonal_hg","text":"diagonal_hg(x, y, z=zero(eltype(x)); m=0, n=0, w=one(eltype(x)), k=one(eltype(x)))\n\nCompute a diagonal Hermite-Gaussian mode. It is calculated by setting θ=π/4 in hg.\n\nSee also lg.\n\n\n\n\n\n","category":"function"},{"location":"initial_profiles/#Examples-3","page":"Initial Profiles","title":"Examples","text":"","category":"section"},{"location":"initial_profiles/","page":"Initial Profiles","title":"Initial Profiles","text":"Analytical propagation of a Hermite-Gauss with adjusted wavenumber:","category":"page"},{"location":"initial_profiles/","page":"Initial Profiles","title":"Initial Profiles","text":"using StructuredLight, CairoMakie\r\nrs = LinRange(-5,5,256) \r\nzs = LinRange(0,1,32)\r\nψs = diagonal_hg(rs,rs,zs,m=4,n=3,k=2)\r\nsave_animation(abs2.(ψs),\"prop_adjusted_k.mp4\")","category":"page"},{"location":"initial_profiles/","page":"Initial Profiles","title":"Initial Profiles","text":"(Image: )","category":"page"},{"location":"initial_profiles/#Lenses","page":"Initial Profiles","title":"Lenses","text":"","category":"section"},{"location":"initial_profiles/","page":"Initial Profiles","title":"Initial Profiles","text":"We also implement lenses:","category":"page"},{"location":"initial_profiles/","page":"Initial Profiles","title":"Initial Profiles","text":"lens\r\ntilted_lens","category":"page"},{"location":"initial_profiles/#StructuredLight.lens","page":"Initial Profiles","title":"StructuredLight.lens","text":"lens(x,y,fx,fy;k=1)\n\nOutput an array containing the phase shift introduced by a lens of focal lengths fx and fy.\n\nThe calculation is done over a grid defined by x and y.\n\nk is the incident wavenumber.\n\nTo apply the lens at a beam ψ₀, just calculate ψ = ψ₀ .* lens(x,y,fx,fy;k=k)\n\n\n\n\n\n","category":"function"},{"location":"initial_profiles/#StructuredLight.tilted_lens","page":"Initial Profiles","title":"StructuredLight.tilted_lens","text":"tilted_lens(x,y,f,ϕ;k=1)\n\nOutput an array containing the phase shift introduced by a spherical lens of focal length f tilted by an angle ϕ.\n\nThe calculation is done over a grid defined by x and y.\n\nk is the incident wavenumber.\n\nTo apply the lens at a beam ψ₀, just calculate ψ = ψ₀ .* tilted_lens(x,y,f,ϕ;k=k)\n\n\n\n\n\n","category":"function"}]
}
